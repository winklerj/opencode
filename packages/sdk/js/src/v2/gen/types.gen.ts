// This file is auto-generated by @hey-api/openapi-ts

export type ClientOptions = {
  baseUrl: `${string}://${string}` | (string & {})
}

export type EventInstallationUpdated = {
  type: "installation.updated"
  properties: {
    version: string
  }
}

export type EventInstallationUpdateAvailable = {
  type: "installation.update-available"
  properties: {
    version: string
  }
}

export type Project = {
  id: string
  worktree: string
  vcs?: "git"
  name?: string
  icon?: {
    url?: string
    color?: string
  }
  time: {
    created: number
    updated: number
    initialized?: number
  }
  sandboxes: Array<string>
}

export type EventProjectUpdated = {
  type: "project.updated"
  properties: Project
}

export type EventServerInstanceDisposed = {
  type: "server.instance.disposed"
  properties: {
    directory: string
  }
}

export type EventLspClientDiagnostics = {
  type: "lsp.client.diagnostics"
  properties: {
    serverID: string
    path: string
  }
}

export type EventLspUpdated = {
  type: "lsp.updated"
  properties: {
    [key: string]: unknown
  }
}

export type SessionStatus =
  | {
      type: "idle"
    }
  | {
      type: "retry"
      attempt: number
      message: string
      next: number
    }
  | {
      type: "busy"
    }

export type EventSessionStatus = {
  type: "session.status"
  properties: {
    sessionID: string
    status: SessionStatus
  }
}

export type EventSessionIdle = {
  type: "session.idle"
  properties: {
    sessionID: string
  }
}

export type FileDiff = {
  file: string
  before: string
  after: string
  additions: number
  deletions: number
}

export type UserMessage = {
  id: string
  sessionID: string
  role: "user"
  time: {
    created: number
  }
  summary?: {
    title?: string
    body?: string
    diffs: Array<FileDiff>
  }
  agent: string
  model: {
    providerID: string
    modelID: string
  }
  system?: string
  tools?: {
    [key: string]: boolean
  }
  variant?: string
}

export type ProviderAuthError = {
  name: "ProviderAuthError"
  data: {
    providerID: string
    message: string
  }
}

export type UnknownError = {
  name: "UnknownError"
  data: {
    message: string
  }
}

export type MessageOutputLengthError = {
  name: "MessageOutputLengthError"
  data: {
    [key: string]: unknown
  }
}

export type MessageAbortedError = {
  name: "MessageAbortedError"
  data: {
    message: string
  }
}

export type ApiError = {
  name: "APIError"
  data: {
    message: string
    statusCode?: number
    isRetryable: boolean
    responseHeaders?: {
      [key: string]: string
    }
    responseBody?: string
    metadata?: {
      [key: string]: string
    }
  }
}

export type AssistantMessage = {
  id: string
  sessionID: string
  role: "assistant"
  time: {
    created: number
    completed?: number
  }
  error?: ProviderAuthError | UnknownError | MessageOutputLengthError | MessageAbortedError | ApiError
  parentID: string
  modelID: string
  providerID: string
  mode: string
  agent: string
  path: {
    cwd: string
    root: string
  }
  summary?: boolean
  cost: number
  tokens: {
    input: number
    output: number
    reasoning: number
    cache: {
      read: number
      write: number
    }
  }
  finish?: string
}

export type Message = UserMessage | AssistantMessage

export type EventMessageUpdated = {
  type: "message.updated"
  properties: {
    info: Message
  }
}

export type EventMessageRemoved = {
  type: "message.removed"
  properties: {
    sessionID: string
    messageID: string
  }
}

export type TextPart = {
  id: string
  sessionID: string
  messageID: string
  type: "text"
  text: string
  synthetic?: boolean
  ignored?: boolean
  time?: {
    start: number
    end?: number
  }
  metadata?: {
    [key: string]: unknown
  }
}

export type ReasoningPart = {
  id: string
  sessionID: string
  messageID: string
  type: "reasoning"
  text: string
  metadata?: {
    [key: string]: unknown
  }
  time: {
    start: number
    end?: number
  }
}

export type FilePartSourceText = {
  value: string
  start: number
  end: number
}

export type FileSource = {
  text: FilePartSourceText
  type: "file"
  path: string
}

export type Range = {
  start: {
    line: number
    character: number
  }
  end: {
    line: number
    character: number
  }
}

export type SymbolSource = {
  text: FilePartSourceText
  type: "symbol"
  path: string
  range: Range
  name: string
  kind: number
}

export type ResourceSource = {
  text: FilePartSourceText
  type: "resource"
  clientName: string
  uri: string
}

export type FilePartSource = FileSource | SymbolSource | ResourceSource

export type FilePart = {
  id: string
  sessionID: string
  messageID: string
  type: "file"
  mime: string
  filename?: string
  url: string
  source?: FilePartSource
}

export type ToolStatePending = {
  status: "pending"
  input: {
    [key: string]: unknown
  }
  raw: string
}

export type ToolStateRunning = {
  status: "running"
  input: {
    [key: string]: unknown
  }
  title?: string
  metadata?: {
    [key: string]: unknown
  }
  time: {
    start: number
  }
}

export type ToolStateCompleted = {
  status: "completed"
  input: {
    [key: string]: unknown
  }
  output: string
  title: string
  metadata: {
    [key: string]: unknown
  }
  time: {
    start: number
    end: number
    compacted?: number
  }
  attachments?: Array<FilePart>
}

export type ToolStateError = {
  status: "error"
  input: {
    [key: string]: unknown
  }
  error: string
  metadata?: {
    [key: string]: unknown
  }
  time: {
    start: number
    end: number
  }
}

export type ToolState = ToolStatePending | ToolStateRunning | ToolStateCompleted | ToolStateError

export type ToolPart = {
  id: string
  sessionID: string
  messageID: string
  type: "tool"
  callID: string
  tool: string
  state: ToolState
  metadata?: {
    [key: string]: unknown
  }
}

export type StepStartPart = {
  id: string
  sessionID: string
  messageID: string
  type: "step-start"
  snapshot?: string
}

export type StepFinishPart = {
  id: string
  sessionID: string
  messageID: string
  type: "step-finish"
  reason: string
  snapshot?: string
  cost: number
  tokens: {
    input: number
    output: number
    reasoning: number
    cache: {
      read: number
      write: number
    }
  }
}

export type SnapshotPart = {
  id: string
  sessionID: string
  messageID: string
  type: "snapshot"
  snapshot: string
}

export type PatchPart = {
  id: string
  sessionID: string
  messageID: string
  type: "patch"
  hash: string
  files: Array<string>
}

export type AgentPart = {
  id: string
  sessionID: string
  messageID: string
  type: "agent"
  name: string
  source?: {
    value: string
    start: number
    end: number
  }
}

export type RetryPart = {
  id: string
  sessionID: string
  messageID: string
  type: "retry"
  attempt: number
  error: ApiError
  time: {
    created: number
  }
}

export type CompactionPart = {
  id: string
  sessionID: string
  messageID: string
  type: "compaction"
  auto: boolean
}

export type Part =
  | TextPart
  | {
      id: string
      sessionID: string
      messageID: string
      type: "subtask"
      prompt: string
      description: string
      agent: string
      command?: string
    }
  | ReasoningPart
  | FilePart
  | ToolPart
  | StepStartPart
  | StepFinishPart
  | SnapshotPart
  | PatchPart
  | AgentPart
  | RetryPart
  | CompactionPart

export type EventMessagePartUpdated = {
  type: "message.part.updated"
  properties: {
    part: Part
    delta?: string
  }
}

export type EventMessagePartRemoved = {
  type: "message.part.removed"
  properties: {
    sessionID: string
    messageID: string
    partID: string
  }
}

export type PermissionRequest = {
  id: string
  sessionID: string
  permission: string
  patterns: Array<string>
  metadata: {
    [key: string]: unknown
  }
  always: Array<string>
  tool?: {
    messageID: string
    callID: string
  }
}

export type EventPermissionAsked = {
  type: "permission.asked"
  properties: PermissionRequest
}

export type EventPermissionReplied = {
  type: "permission.replied"
  properties: {
    sessionID: string
    requestID: string
    reply: "once" | "always" | "reject"
  }
}

export type QuestionOption = {
  /**
   * Display text (1-5 words, concise)
   */
  label: string
  /**
   * Explanation of choice
   */
  description: string
}

export type QuestionInfo = {
  /**
   * Complete question
   */
  question: string
  /**
   * Very short label (max 12 chars)
   */
  header: string
  /**
   * Available choices
   */
  options: Array<QuestionOption>
  /**
   * Allow selecting multiple choices
   */
  multiple?: boolean
}

export type QuestionRequest = {
  id: string
  sessionID: string
  /**
   * Questions to ask
   */
  questions: Array<QuestionInfo>
  tool?: {
    messageID: string
    callID: string
  }
}

export type EventQuestionAsked = {
  type: "question.asked"
  properties: QuestionRequest
}

export type QuestionAnswer = Array<string>

export type EventQuestionReplied = {
  type: "question.replied"
  properties: {
    sessionID: string
    requestID: string
    answers: Array<QuestionAnswer>
  }
}

export type EventQuestionRejected = {
  type: "question.rejected"
  properties: {
    sessionID: string
    requestID: string
  }
}

export type EventSessionCompacted = {
  type: "session.compacted"
  properties: {
    sessionID: string
  }
}

export type EventFileEdited = {
  type: "file.edited"
  properties: {
    file: string
  }
}

export type Todo = {
  /**
   * Brief description of the task
   */
  content: string
  /**
   * Current status of the task: pending, in_progress, completed, cancelled
   */
  status: string
  /**
   * Priority level of the task: high, medium, low
   */
  priority: string
  /**
   * Unique identifier for the todo item
   */
  id: string
}

export type EventTodoUpdated = {
  type: "todo.updated"
  properties: {
    sessionID: string
    todos: Array<Todo>
  }
}

export type EventDesktopStarted = {
  type: "desktop.started"
  properties: {
    sandboxID: string
    vncUrl: string
  }
}

export type EventDesktopStopped = {
  type: "desktop.stopped"
  properties: {
    sandboxID: string
  }
}

export type EventDesktopError = {
  type: "desktop.error"
  properties: {
    sandboxID: string
    error: string
  }
}

export type EventTuiPromptAppend = {
  type: "tui.prompt.append"
  properties: {
    text: string
  }
}

export type EventTuiCommandExecute = {
  type: "tui.command.execute"
  properties: {
    command:
      | "session.list"
      | "session.new"
      | "session.share"
      | "session.interrupt"
      | "session.compact"
      | "session.page.up"
      | "session.page.down"
      | "session.half.page.up"
      | "session.half.page.down"
      | "session.first"
      | "session.last"
      | "prompt.clear"
      | "prompt.submit"
      | "agent.cycle"
      | string
  }
}

export type EventTuiToastShow = {
  type: "tui.toast.show"
  properties: {
    title?: string
    message: string
    variant: "info" | "success" | "warning" | "error"
    /**
     * Duration in milliseconds
     */
    duration?: number
  }
}

export type EventTuiSessionSelect = {
  type: "tui.session.select"
  properties: {
    /**
     * Session ID to navigate to
     */
    sessionID: string
  }
}

export type EventMcpToolsChanged = {
  type: "mcp.tools.changed"
  properties: {
    server: string
  }
}

export type EventCommandExecuted = {
  type: "command.executed"
  properties: {
    name: string
    sessionID: string
    arguments: string
    messageID: string
  }
}

export type PermissionAction = "allow" | "deny" | "ask"

export type PermissionRule = {
  permission: string
  pattern: string
  action: PermissionAction
}

export type PermissionRuleset = Array<PermissionRule>

export type Session = {
  id: string
  projectID: string
  directory: string
  parentID?: string
  summary?: {
    additions: number
    deletions: number
    files: number
    diffs?: Array<FileDiff>
  }
  share?: {
    url: string
  }
  title: string
  version: string
  time: {
    created: number
    updated: number
    compacting?: number
    archived?: number
  }
  permission?: PermissionRuleset
  revert?: {
    messageID: string
    partID?: string
    snapshot?: string
    diff?: string
  }
}

export type EventSessionCreated = {
  type: "session.created"
  properties: {
    info: Session
  }
}

export type EventSessionUpdated = {
  type: "session.updated"
  properties: {
    info: Session
  }
}

export type EventSessionDeleted = {
  type: "session.deleted"
  properties: {
    info: Session
  }
}

export type EventSessionDiff = {
  type: "session.diff"
  properties: {
    sessionID: string
    diff: Array<FileDiff>
  }
}

export type EventSessionError = {
  type: "session.error"
  properties: {
    sessionID?: string
    error?: ProviderAuthError | UnknownError | MessageOutputLengthError | MessageAbortedError | ApiError
  }
}

export type EventFileWatcherUpdated = {
  type: "file.watcher.updated"
  properties: {
    file: string
    event: "add" | "change" | "unlink"
  }
}

export type EventVcsBranchUpdated = {
  type: "vcs.branch.updated"
  properties: {
    branch?: string
  }
}

export type EventVoiceStarted = {
  type: "voice.started"
  properties: {
    sessionID: string
  }
}

export type EventVoiceStopped = {
  type: "voice.stopped"
  properties: {
    sessionID: string
  }
}

export type EventVoiceTranscribed = {
  type: "voice.transcribed"
  properties: {
    sessionID: string
    transcript: {
      text: string
      isFinal: boolean
      confidence: number
      language?: string
    }
  }
}

export type EventVoiceError = {
  type: "voice.error"
  properties: {
    sessionID: string
    error: string
  }
}

export type EventEditorStarted = {
  type: "editor.started"
  properties: {
    sandboxID: string
    url: string
  }
}

export type EventEditorStopped = {
  type: "editor.stopped"
  properties: {
    sandboxID: string
  }
}

export type EventEditorError = {
  type: "editor.error"
  properties: {
    sandboxID: string
    error: string
  }
}

export type EventPrSessionCreated = {
  type: "pr-session.created"
  properties: {
    prNumber: number
    sessionID: string
    repository: string
  }
}

export type EventPrSessionCommentAddressed = {
  type: "pr-session.comment.addressed"
  properties: {
    prNumber: number
    commentID: string
    response: string
  }
}

export type EventWebhookGithubReceived = {
  type: "webhook.github.received"
  properties: {
    event:
      | "pull_request"
      | "pull_request_review"
      | "pull_request_review_comment"
      | "issue_comment"
      | "push"
      | "check_run"
      | "check_suite"
      | "workflow_run"
      | "ping"
    action?: string
    repository?: string
  }
}

export type EventWebhookSlackEventReceived = {
  type: "webhook.slack.event.received"
  properties: {
    type: string
    channel?: string
    user?: string
  }
}

export type EventWebhookSlackInteractionReceived = {
  type: "webhook.slack.interaction.received"
  properties: {
    type: string
    user?: string
  }
}

export type Pty = {
  id: string
  title: string
  command: string
  args: Array<string>
  cwd: string
  status: "running" | "exited"
  pid: number
}

export type EventPtyCreated = {
  type: "pty.created"
  properties: {
    info: Pty
  }
}

export type EventPtyUpdated = {
  type: "pty.updated"
  properties: {
    info: Pty
  }
}

export type EventPtyExited = {
  type: "pty.exited"
  properties: {
    id: string
    exitCode: number
  }
}

export type EventPtyDeleted = {
  type: "pty.deleted"
  properties: {
    id: string
  }
}

export type EventServerConnected = {
  type: "server.connected"
  properties: {
    [key: string]: unknown
  }
}

export type EventGlobalDisposed = {
  type: "global.disposed"
  properties: {
    [key: string]: unknown
  }
}

export type Event =
  | EventInstallationUpdated
  | EventInstallationUpdateAvailable
  | EventProjectUpdated
  | EventServerInstanceDisposed
  | EventLspClientDiagnostics
  | EventLspUpdated
  | EventSessionStatus
  | EventSessionIdle
  | EventMessageUpdated
  | EventMessageRemoved
  | EventMessagePartUpdated
  | EventMessagePartRemoved
  | EventPermissionAsked
  | EventPermissionReplied
  | EventQuestionAsked
  | EventQuestionReplied
  | EventQuestionRejected
  | EventSessionCompacted
  | EventFileEdited
  | EventTodoUpdated
  | EventDesktopStarted
  | EventDesktopStopped
  | EventDesktopError
  | EventTuiPromptAppend
  | EventTuiCommandExecute
  | EventTuiToastShow
  | EventTuiSessionSelect
  | EventMcpToolsChanged
  | EventCommandExecuted
  | EventSessionCreated
  | EventSessionUpdated
  | EventSessionDeleted
  | EventSessionDiff
  | EventSessionError
  | EventFileWatcherUpdated
  | EventVcsBranchUpdated
  | EventVoiceStarted
  | EventVoiceStopped
  | EventVoiceTranscribed
  | EventVoiceError
  | EventEditorStarted
  | EventEditorStopped
  | EventEditorError
  | EventPrSessionCreated
  | EventPrSessionCommentAddressed
  | EventWebhookGithubReceived
  | EventWebhookSlackEventReceived
  | EventWebhookSlackInteractionReceived
  | EventPtyCreated
  | EventPtyUpdated
  | EventPtyExited
  | EventPtyDeleted
  | EventServerConnected
  | EventGlobalDisposed

export type GlobalEvent = {
  directory: string
  payload: Event
}

export type BadRequestError = {
  data: unknown
  errors: Array<{
    [key: string]: unknown
  }>
  success: false
}

export type NotFoundError = {
  name: "NotFoundError"
  data: {
    message: string
  }
}

/**
 * Custom keybind configurations
 */
export type KeybindsConfig = {
  /**
   * Leader key for keybind combinations
   */
  leader?: string
  /**
   * Exit the application
   */
  app_exit?: string
  /**
   * Open external editor
   */
  editor_open?: string
  /**
   * List available themes
   */
  theme_list?: string
  /**
   * Toggle sidebar
   */
  sidebar_toggle?: string
  /**
   * Toggle session scrollbar
   */
  scrollbar_toggle?: string
  /**
   * Toggle username visibility
   */
  username_toggle?: string
  /**
   * View status
   */
  status_view?: string
  /**
   * Export session to editor
   */
  session_export?: string
  /**
   * Create a new session
   */
  session_new?: string
  /**
   * List all sessions
   */
  session_list?: string
  /**
   * Show session timeline
   */
  session_timeline?: string
  /**
   * Fork session from message
   */
  session_fork?: string
  /**
   * Rename session
   */
  session_rename?: string
  /**
   * Share current session
   */
  session_share?: string
  /**
   * Unshare current session
   */
  session_unshare?: string
  /**
   * Interrupt current session
   */
  session_interrupt?: string
  /**
   * Compact the session
   */
  session_compact?: string
  /**
   * Scroll messages up by one page
   */
  messages_page_up?: string
  /**
   * Scroll messages down by one page
   */
  messages_page_down?: string
  /**
   * Scroll messages up by half page
   */
  messages_half_page_up?: string
  /**
   * Scroll messages down by half page
   */
  messages_half_page_down?: string
  /**
   * Navigate to first message
   */
  messages_first?: string
  /**
   * Navigate to last message
   */
  messages_last?: string
  /**
   * Navigate to next message
   */
  messages_next?: string
  /**
   * Navigate to previous message
   */
  messages_previous?: string
  /**
   * Navigate to last user message
   */
  messages_last_user?: string
  /**
   * Copy message
   */
  messages_copy?: string
  /**
   * Undo message
   */
  messages_undo?: string
  /**
   * Redo message
   */
  messages_redo?: string
  /**
   * Toggle code block concealment in messages
   */
  messages_toggle_conceal?: string
  /**
   * Toggle tool details visibility
   */
  tool_details?: string
  /**
   * List available models
   */
  model_list?: string
  /**
   * Next recently used model
   */
  model_cycle_recent?: string
  /**
   * Previous recently used model
   */
  model_cycle_recent_reverse?: string
  /**
   * Next favorite model
   */
  model_cycle_favorite?: string
  /**
   * Previous favorite model
   */
  model_cycle_favorite_reverse?: string
  /**
   * List available commands
   */
  command_list?: string
  /**
   * List agents
   */
  agent_list?: string
  /**
   * Next agent
   */
  agent_cycle?: string
  /**
   * Previous agent
   */
  agent_cycle_reverse?: string
  /**
   * Cycle model variants
   */
  variant_cycle?: string
  /**
   * Clear input field
   */
  input_clear?: string
  /**
   * Paste from clipboard
   */
  input_paste?: string
  /**
   * Submit input
   */
  input_submit?: string
  /**
   * Insert newline in input
   */
  input_newline?: string
  /**
   * Move cursor left in input
   */
  input_move_left?: string
  /**
   * Move cursor right in input
   */
  input_move_right?: string
  /**
   * Move cursor up in input
   */
  input_move_up?: string
  /**
   * Move cursor down in input
   */
  input_move_down?: string
  /**
   * Select left in input
   */
  input_select_left?: string
  /**
   * Select right in input
   */
  input_select_right?: string
  /**
   * Select up in input
   */
  input_select_up?: string
  /**
   * Select down in input
   */
  input_select_down?: string
  /**
   * Move to start of line in input
   */
  input_line_home?: string
  /**
   * Move to end of line in input
   */
  input_line_end?: string
  /**
   * Select to start of line in input
   */
  input_select_line_home?: string
  /**
   * Select to end of line in input
   */
  input_select_line_end?: string
  /**
   * Move to start of visual line in input
   */
  input_visual_line_home?: string
  /**
   * Move to end of visual line in input
   */
  input_visual_line_end?: string
  /**
   * Select to start of visual line in input
   */
  input_select_visual_line_home?: string
  /**
   * Select to end of visual line in input
   */
  input_select_visual_line_end?: string
  /**
   * Move to start of buffer in input
   */
  input_buffer_home?: string
  /**
   * Move to end of buffer in input
   */
  input_buffer_end?: string
  /**
   * Select to start of buffer in input
   */
  input_select_buffer_home?: string
  /**
   * Select to end of buffer in input
   */
  input_select_buffer_end?: string
  /**
   * Delete line in input
   */
  input_delete_line?: string
  /**
   * Delete to end of line in input
   */
  input_delete_to_line_end?: string
  /**
   * Delete to start of line in input
   */
  input_delete_to_line_start?: string
  /**
   * Backspace in input
   */
  input_backspace?: string
  /**
   * Delete character in input
   */
  input_delete?: string
  /**
   * Undo in input
   */
  input_undo?: string
  /**
   * Redo in input
   */
  input_redo?: string
  /**
   * Move word forward in input
   */
  input_word_forward?: string
  /**
   * Move word backward in input
   */
  input_word_backward?: string
  /**
   * Select word forward in input
   */
  input_select_word_forward?: string
  /**
   * Select word backward in input
   */
  input_select_word_backward?: string
  /**
   * Delete word forward in input
   */
  input_delete_word_forward?: string
  /**
   * Delete word backward in input
   */
  input_delete_word_backward?: string
  /**
   * Previous history item
   */
  history_previous?: string
  /**
   * Next history item
   */
  history_next?: string
  /**
   * Next child session
   */
  session_child_cycle?: string
  /**
   * Previous child session
   */
  session_child_cycle_reverse?: string
  /**
   * Go to parent session
   */
  session_parent?: string
  /**
   * Suspend terminal
   */
  terminal_suspend?: string
  /**
   * Toggle terminal title
   */
  terminal_title_toggle?: string
  /**
   * Toggle tips on home screen
   */
  tips_toggle?: string
}

/**
 * Log level
 */
export type LogLevel = "DEBUG" | "INFO" | "WARN" | "ERROR"

/**
 * Server configuration for opencode serve and web commands
 */
export type ServerConfig = {
  /**
   * Port to listen on
   */
  port?: number
  /**
   * Hostname to listen on
   */
  hostname?: string
  /**
   * Enable mDNS service discovery
   */
  mdns?: boolean
  /**
   * Additional domains to allow for CORS
   */
  cors?: Array<string>
}

export type PermissionActionConfig = "ask" | "allow" | "deny"

export type PermissionObjectConfig = {
  [key: string]: PermissionActionConfig
}

export type PermissionRuleConfig = PermissionActionConfig | PermissionObjectConfig

export type PermissionConfig =
  | {
      __originalKeys?: Array<string>
      read?: PermissionRuleConfig
      edit?: PermissionRuleConfig
      glob?: PermissionRuleConfig
      grep?: PermissionRuleConfig
      list?: PermissionRuleConfig
      bash?: PermissionRuleConfig
      task?: PermissionRuleConfig
      external_directory?: PermissionRuleConfig
      todowrite?: PermissionActionConfig
      todoread?: PermissionActionConfig
      question?: PermissionActionConfig
      webfetch?: PermissionActionConfig
      websearch?: PermissionActionConfig
      codesearch?: PermissionActionConfig
      lsp?: PermissionRuleConfig
      doom_loop?: PermissionActionConfig
      [key: string]: PermissionRuleConfig | Array<string> | PermissionActionConfig | undefined
    }
  | PermissionActionConfig

export type AgentConfig = {
  model?: string
  temperature?: number
  top_p?: number
  prompt?: string
  /**
   * @deprecated Use 'permission' field instead
   */
  tools?: {
    [key: string]: boolean
  }
  disable?: boolean
  /**
   * Description of when to use the agent
   */
  description?: string
  mode?: "subagent" | "primary" | "all"
  /**
   * Hide this subagent from the @ autocomplete menu (default: false, only applies to mode: subagent)
   */
  hidden?: boolean
  options?: {
    [key: string]: unknown
  }
  /**
   * Hex color code for the agent (e.g., #FF5733)
   */
  color?: string
  /**
   * Maximum number of agentic iterations before forcing text-only response
   */
  steps?: number
  /**
   * @deprecated Use 'steps' field instead.
   */
  maxSteps?: number
  permission?: PermissionConfig
  [key: string]:
    | unknown
    | string
    | number
    | {
        [key: string]: boolean
      }
    | boolean
    | "subagent"
    | "primary"
    | "all"
    | {
        [key: string]: unknown
      }
    | string
    | number
    | PermissionConfig
    | undefined
}

export type ProviderConfig = {
  api?: string
  name?: string
  env?: Array<string>
  id?: string
  npm?: string
  models?: {
    [key: string]: {
      id?: string
      name?: string
      family?: string
      release_date?: string
      attachment?: boolean
      reasoning?: boolean
      temperature?: boolean
      tool_call?: boolean
      interleaved?:
        | true
        | {
            field: "reasoning_content" | "reasoning_details"
          }
      cost?: {
        input: number
        output: number
        cache_read?: number
        cache_write?: number
        context_over_200k?: {
          input: number
          output: number
          cache_read?: number
          cache_write?: number
        }
      }
      limit?: {
        context: number
        output: number
      }
      modalities?: {
        input: Array<"text" | "audio" | "image" | "video" | "pdf">
        output: Array<"text" | "audio" | "image" | "video" | "pdf">
      }
      experimental?: boolean
      status?: "alpha" | "beta" | "deprecated"
      options?: {
        [key: string]: unknown
      }
      headers?: {
        [key: string]: string
      }
      provider?: {
        npm: string
      }
      /**
       * Variant-specific configuration
       */
      variants?: {
        [key: string]: {
          /**
           * Disable this variant for the model
           */
          disabled?: boolean
          [key: string]: unknown | boolean | undefined
        }
      }
    }
  }
  whitelist?: Array<string>
  blacklist?: Array<string>
  options?: {
    apiKey?: string
    baseURL?: string
    /**
     * GitHub Enterprise URL for copilot authentication
     */
    enterpriseUrl?: string
    /**
     * Enable promptCacheKey for this provider (default false)
     */
    setCacheKey?: boolean
    /**
     * Timeout in milliseconds for requests to this provider. Default is 300000 (5 minutes). Set to false to disable timeout.
     */
    timeout?: number | false
    [key: string]: unknown | string | boolean | number | false | undefined
  }
}

export type McpLocalConfig = {
  /**
   * Type of MCP server connection
   */
  type: "local"
  /**
   * Command and arguments to run the MCP server
   */
  command: Array<string>
  /**
   * Environment variables to set when running the MCP server
   */
  environment?: {
    [key: string]: string
  }
  /**
   * Enable or disable the MCP server on startup
   */
  enabled?: boolean
  /**
   * Timeout in ms for fetching tools from the MCP server. Defaults to 5000 (5 seconds) if not specified.
   */
  timeout?: number
}

export type McpOAuthConfig = {
  /**
   * OAuth client ID. If not provided, dynamic client registration (RFC 7591) will be attempted.
   */
  clientId?: string
  /**
   * OAuth client secret (if required by the authorization server)
   */
  clientSecret?: string
  /**
   * OAuth scopes to request during authorization
   */
  scope?: string
}

export type McpRemoteConfig = {
  /**
   * Type of MCP server connection
   */
  type: "remote"
  /**
   * URL of the remote MCP server
   */
  url: string
  /**
   * Enable or disable the MCP server on startup
   */
  enabled?: boolean
  /**
   * Headers to send with the request
   */
  headers?: {
    [key: string]: string
  }
  /**
   * OAuth authentication configuration for the MCP server. Set to false to disable OAuth auto-detection.
   */
  oauth?: McpOAuthConfig | false
  /**
   * Timeout in ms for fetching tools from the MCP server. Defaults to 5000 (5 seconds) if not specified.
   */
  timeout?: number
}

/**
 * @deprecated Always uses stretch layout.
 */
export type LayoutConfig = "auto" | "stretch"

/**
 * Hosted background agent configuration
 */
export type HostedConfig = {
  /**
   * Enable hosted background agent features
   */
  enabled?: boolean
  /**
   * Sandbox configuration for hosted agents
   */
  sandbox?: {
    /**
     * Sandbox provider
     */
    provider?: "modal" | "local"
    /**
     * Default container image for sandboxes
     */
    defaultImage?: string
    /**
     * Services to run in sandbox
     */
    services?: Array<string>
    warmPool?: {
      /**
       * Enable warm pool
       */
      enabled?: boolean
      /**
       * Number of warm sandboxes to maintain
       */
      size?: number
      /**
       * Time-to-live for warm sandboxes in seconds
       */
      ttl?: number
      /**
       * Warm sandbox on keystroke
       */
      typingTrigger?: boolean
    }
    resources?: {
      /**
       * CPU cores
       */
      cpu?: number
      /**
       * Memory in MB
       */
      memory?: number
      /**
       * Disk space in GB
       */
      disk?: number
    }
    editor?: {
      /**
       * Enable VS Code in sandbox
       */
      enabled?: boolean
      type?: "code-server" | "openvscode-server"
      port?: number
      /**
       * Pre-installed extensions
       */
      extensions?: Array<string>
    }
    desktop?: {
      /**
       * Enable desktop streaming
       */
      enabled?: boolean
      resolution?: {
        width?: number
        height?: number
      }
      vncPort?: number
    }
    imageBuild?: {
      /**
       * Rebuild interval in seconds
       */
      rebuildInterval?: number
      runTestsDuringBuild?: boolean
      /**
       * Test timeout in ms
       */
      testTimeout?: number
      cacheWarmup?: boolean
    }
    /**
     * Security constraints for sandbox isolation
     */
    security?: {
      network?: {
        /**
         * Allowed egress patterns
         */
        allowedEgress?: Array<string>
        /**
         * Denied egress patterns (cloud metadata endpoints)
         */
        denyEgress?: Array<string>
      }
      filesystem?: {
        /**
         * Paths that should be read-only
         */
        readOnlyPaths?: Array<string>
        /**
         * Paths that are writable
         */
        writablePaths?: Array<string>
      }
      limits?: {
        /**
         * Maximum number of processes
         */
        maxProcesses?: number
        /**
         * Maximum memory in MB
         */
        maxMemoryMB?: number
        /**
         * Maximum execution time in ms
         */
        maxExecutionTimeMs?: number
        /**
         * Maximum open files
         */
        maxOpenFiles?: number
      }
    }
  }
  multiplayer?: {
    /**
     * Enable multiplayer sessions
     */
    enabled?: boolean
    stateProvider?: "cloudflare" | "memory"
  }
  background?: {
    /**
     * Enable background agents
     */
    enabled?: boolean
    /**
     * Max concurrent sessions
     */
    maxConcurrent?: number
    /**
     * Default timeout in ms
     */
    defaultTimeout?: number
  }
  /**
   * Skills configuration
   */
  skills?: {
    /**
     * Enable skills system
     */
    enabled?: boolean
    /**
     * Skills directory
     */
    directory?: string
    /**
     * Built-in skills to enable
     */
    builtIn?: Array<string>
    custom?: Array<{
      name: string
      description: string
      prompt: string
      tools?: Array<string>
      model?: string
    }>
  }
  voice?: {
    /**
     * Enable voice interface
     */
    enabled?: boolean
    lang?: string
    continuous?: boolean
    interimResults?: boolean
    /**
     * Delay before finalizing speech in ms
     */
    commitDelay?: number
  }
  /**
   * Integration configurations
   */
  integrations?: {
    github?: {
      enabled: boolean
      webhooks?: {
        secret: string
        events: Array<string>
      }
      /**
       * GitHub App ID for image building
       */
      appId?: string
      appPrivateKey?: string
      appInstallationId?: string
    }
    slack?: {
      enabled: boolean
      botToken: string
      signingSecret?: string
      classifier?: {
        model?: string
        confidenceThreshold?: number
        allowUnknown?: boolean
        hints?: Array<{
          channelPattern: string
          repository: string
          keywords?: Array<string>
        }>
      }
    }
    sentry?: {
      enabled: boolean
      dsn: string
    }
    datadog?: {
      enabled: boolean
      apiKey: string
    }
    launchDarkly?: {
      enabled: boolean
      sdkKey: string
    }
    braintrust?: {
      enabled: boolean
      apiKey: string
    }
    buildkite?: {
      enabled: boolean
      token: string
    }
  }
}

export type Config = {
  /**
   * JSON schema reference for configuration validation
   */
  $schema?: string
  /**
   * Theme name to use for the interface
   */
  theme?: string
  keybinds?: KeybindsConfig
  logLevel?: LogLevel
  /**
   * TUI specific settings
   */
  tui?: {
    /**
     * TUI scroll speed
     */
    scroll_speed?: number
    /**
     * Scroll acceleration settings
     */
    scroll_acceleration?: {
      /**
       * Enable scroll acceleration
       */
      enabled: boolean
    }
    /**
     * Control diff rendering style: 'auto' adapts to terminal width, 'stacked' always shows single column
     */
    diff_style?: "auto" | "stacked"
  }
  server?: ServerConfig
  /**
   * Command configuration, see https://opencode.ai/docs/commands
   */
  command?: {
    [key: string]: {
      template: string
      description?: string
      agent?: string
      model?: string
      subtask?: boolean
    }
  }
  watcher?: {
    ignore?: Array<string>
  }
  plugin?: Array<string>
  snapshot?: boolean
  /**
   * Control sharing behavior:'manual' allows manual sharing via commands, 'auto' enables automatic sharing, 'disabled' disables all sharing
   */
  share?: "manual" | "auto" | "disabled"
  /**
   * @deprecated Use 'share' field instead. Share newly created sessions automatically
   */
  autoshare?: boolean
  /**
   * Automatically update to the latest version. Set to true to auto-update, false to disable, or 'notify' to show update notifications
   */
  autoupdate?: boolean | "notify"
  /**
   * Disable providers that are loaded automatically
   */
  disabled_providers?: Array<string>
  /**
   * When set, ONLY these providers will be enabled. All other providers will be ignored
   */
  enabled_providers?: Array<string>
  /**
   * Model to use in the format of provider/model, eg anthropic/claude-2
   */
  model?: string
  /**
   * Small model to use for tasks like title generation in the format of provider/model
   */
  small_model?: string
  /**
   * Default agent to use when none is specified. Must be a primary agent. Falls back to 'build' if not set or if the specified agent is invalid.
   */
  default_agent?: string
  /**
   * Custom username to display in conversations instead of system username
   */
  username?: string
  /**
   * @deprecated Use `agent` field instead.
   */
  mode?: {
    build?: AgentConfig
    plan?: AgentConfig
    [key: string]: AgentConfig | undefined
  }
  /**
   * Agent configuration, see https://opencode.ai/docs/agent
   */
  agent?: {
    plan?: AgentConfig
    build?: AgentConfig
    general?: AgentConfig
    explore?: AgentConfig
    title?: AgentConfig
    summary?: AgentConfig
    compaction?: AgentConfig
    [key: string]: AgentConfig | undefined
  }
  /**
   * Custom provider configurations and model overrides
   */
  provider?: {
    [key: string]: ProviderConfig
  }
  /**
   * MCP (Model Context Protocol) server configurations
   */
  mcp?: {
    [key: string]:
      | McpLocalConfig
      | McpRemoteConfig
      | {
          enabled: boolean
        }
  }
  formatter?:
    | false
    | {
        [key: string]: {
          disabled?: boolean
          command?: Array<string>
          environment?: {
            [key: string]: string
          }
          extensions?: Array<string>
        }
      }
  lsp?:
    | false
    | {
        [key: string]:
          | {
              disabled: true
            }
          | {
              command: Array<string>
              extensions?: Array<string>
              disabled?: boolean
              env?: {
                [key: string]: string
              }
              initialization?: {
                [key: string]: unknown
              }
            }
      }
  /**
   * Additional instruction files or patterns to include
   */
  instructions?: Array<string>
  layout?: LayoutConfig
  permission?: PermissionConfig
  tools?: {
    [key: string]: boolean
  }
  enterprise?: {
    /**
     * Enterprise URL
     */
    url?: string
  }
  hosted?: HostedConfig
  compaction?: {
    /**
     * Enable automatic compaction when context is full (default: true)
     */
    auto?: boolean
    /**
     * Enable pruning of old tool outputs (default: true)
     */
    prune?: boolean
  }
  experimental?: {
    hook?: {
      file_edited?: {
        [key: string]: Array<{
          command: Array<string>
          environment?: {
            [key: string]: string
          }
        }>
      }
      session_completed?: Array<{
        command: Array<string>
        environment?: {
          [key: string]: string
        }
      }>
    }
    /**
     * Number of retries for chat completions on failure
     */
    chatMaxRetries?: number
    disable_paste_summary?: boolean
    /**
     * Enable the batch tool
     */
    batch_tool?: boolean
    /**
     * Enable OpenTelemetry spans for AI SDK calls (using the 'experimental_telemetry' flag)
     */
    openTelemetry?: boolean
    /**
     * Tools that should only be available to primary agents.
     */
    primary_tools?: Array<string>
    /**
     * Continue the agent loop when a tool call is denied
     */
    continue_loop_on_deny?: boolean
    /**
     * Timeout in milliseconds for model context protocol (MCP) requests
     */
    mcp_timeout?: number
  }
}

export type ToolIds = Array<string>

export type ToolListItem = {
  id: string
  description: string
  parameters: unknown
}

export type ToolList = Array<ToolListItem>

export type Path = {
  home: string
  state: string
  config: string
  worktree: string
  directory: string
}

export type Worktree = {
  name: string
  branch: string
  directory: string
}

export type WorktreeCreateInput = {
  name?: string
  startCommand?: string
}

export type VcsInfo = {
  branch: string
}

export type TextPartInput = {
  id?: string
  type: "text"
  text: string
  synthetic?: boolean
  ignored?: boolean
  time?: {
    start: number
    end?: number
  }
  metadata?: {
    [key: string]: unknown
  }
}

export type FilePartInput = {
  id?: string
  type: "file"
  mime: string
  filename?: string
  url: string
  source?: FilePartSource
}

export type AgentPartInput = {
  id?: string
  type: "agent"
  name: string
  source?: {
    value: string
    start: number
    end: number
  }
}

export type SubtaskPartInput = {
  id?: string
  type: "subtask"
  prompt: string
  description: string
  agent: string
  command?: string
}

export type Command = {
  name: string
  description?: string
  agent?: string
  model?: string
  mcp?: boolean
  template: string
  subtask?: boolean
  hints: Array<string>
}

export type Model = {
  id: string
  providerID: string
  api: {
    id: string
    url: string
    npm: string
  }
  name: string
  family?: string
  capabilities: {
    temperature: boolean
    reasoning: boolean
    attachment: boolean
    toolcall: boolean
    input: {
      text: boolean
      audio: boolean
      image: boolean
      video: boolean
      pdf: boolean
    }
    output: {
      text: boolean
      audio: boolean
      image: boolean
      video: boolean
      pdf: boolean
    }
    interleaved:
      | boolean
      | {
          field: "reasoning_content" | "reasoning_details"
        }
  }
  cost: {
    input: number
    output: number
    cache: {
      read: number
      write: number
    }
    experimentalOver200K?: {
      input: number
      output: number
      cache: {
        read: number
        write: number
      }
    }
  }
  limit: {
    context: number
    output: number
  }
  status: "alpha" | "beta" | "deprecated" | "active"
  options: {
    [key: string]: unknown
  }
  headers: {
    [key: string]: string
  }
  release_date: string
  variants?: {
    [key: string]: {
      [key: string]: unknown
    }
  }
}

export type Provider = {
  id: string
  name: string
  source: "env" | "config" | "custom" | "api"
  env: Array<string>
  key?: string
  options: {
    [key: string]: unknown
  }
  models: {
    [key: string]: Model
  }
}

export type ProviderAuthMethod = {
  type: "oauth" | "api"
  label: string
}

export type ProviderAuthAuthorization = {
  url: string
  method: "auto" | "code"
  instructions: string
}

export type Symbol = {
  name: string
  kind: number
  location: {
    uri: string
    range: Range
  }
}

export type FileNode = {
  name: string
  path: string
  absolute: string
  type: "file" | "directory"
  ignored: boolean
}

export type FileContent = {
  type: "text"
  content: string
  diff?: string
  patch?: {
    oldFileName: string
    newFileName: string
    oldHeader?: string
    newHeader?: string
    hunks: Array<{
      oldStart: number
      oldLines: number
      newStart: number
      newLines: number
      lines: Array<string>
    }>
    index?: string
  }
  encoding?: "base64"
  mimeType?: string
}

export type File = {
  path: string
  added: number
  removed: number
  status: "added" | "deleted" | "modified"
}

export type Agent = {
  name: string
  description?: string
  mode: "subagent" | "primary" | "all"
  native?: boolean
  hidden?: boolean
  topP?: number
  temperature?: number
  color?: string
  permission: PermissionRuleset
  model?: {
    modelID: string
    providerID: string
  }
  prompt?: string
  options: {
    [key: string]: unknown
  }
  steps?: number
}

export type McpStatusConnected = {
  status: "connected"
}

export type McpStatusDisabled = {
  status: "disabled"
}

export type McpStatusFailed = {
  status: "failed"
  error: string
}

export type McpStatusNeedsAuth = {
  status: "needs_auth"
}

export type McpStatusNeedsClientRegistration = {
  status: "needs_client_registration"
  error: string
}

export type McpStatus =
  | McpStatusConnected
  | McpStatusDisabled
  | McpStatusFailed
  | McpStatusNeedsAuth
  | McpStatusNeedsClientRegistration

export type McpResource = {
  name: string
  uri: string
  description?: string
  mimeType?: string
  client: string
}

export type LspStatus = {
  id: string
  name: string
  root: string
  status: "connected" | "error"
}

export type FormatterStatus = {
  name: string
  extensions: Array<string>
  enabled: boolean
}

export type OAuth = {
  type: "oauth"
  refresh: string
  access: string
  expires: number
  accountId?: string
  enterpriseUrl?: string
}

export type ApiAuth = {
  type: "api"
  key: string
}

export type WellKnownAuth = {
  type: "wellknown"
  key: string
  token: string
}

export type Auth = OAuth | ApiAuth | WellKnownAuth

export type GlobalHealthData = {
  body?: never
  path?: never
  query?: never
  url: "/global/health"
}

export type GlobalHealthResponses = {
  /**
   * Health information
   */
  200: {
    healthy: true
    version: string
  }
}

export type GlobalHealthResponse = GlobalHealthResponses[keyof GlobalHealthResponses]

export type GlobalEventData = {
  body?: never
  path?: never
  query?: never
  url: "/global/event"
}

export type GlobalEventResponses = {
  /**
   * Event stream
   */
  200: GlobalEvent
}

export type GlobalEventResponse = GlobalEventResponses[keyof GlobalEventResponses]

export type GlobalDisposeData = {
  body?: never
  path?: never
  query?: never
  url: "/global/dispose"
}

export type GlobalDisposeResponses = {
  /**
   * Global disposed
   */
  200: boolean
}

export type GlobalDisposeResponse = GlobalDisposeResponses[keyof GlobalDisposeResponses]

export type ProjectListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/project"
}

export type ProjectListResponses = {
  /**
   * List of projects
   */
  200: Array<Project>
}

export type ProjectListResponse = ProjectListResponses[keyof ProjectListResponses]

export type ProjectCurrentData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/project/current"
}

export type ProjectCurrentResponses = {
  /**
   * Current project information
   */
  200: Project
}

export type ProjectCurrentResponse = ProjectCurrentResponses[keyof ProjectCurrentResponses]

export type ProjectUpdateData = {
  body?: {
    name?: string
    icon?: {
      url?: string
      color?: string
    }
  }
  path: {
    projectID: string
  }
  query?: {
    directory?: string
  }
  url: "/project/{projectID}"
}

export type ProjectUpdateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type ProjectUpdateError = ProjectUpdateErrors[keyof ProjectUpdateErrors]

export type ProjectUpdateResponses = {
  /**
   * Updated project information
   */
  200: Project
}

export type ProjectUpdateResponse = ProjectUpdateResponses[keyof ProjectUpdateResponses]

export type BackgroundSpawnData = {
  body?: {
    /**
     * ID of the parent session
     */
    parentSessionID: string
    /**
     * Task for the agent to accomplish
     */
    task: string
    type?: "research" | "parallel-work" | "review"
    /**
     * Repository to work with
     */
    repository?: string
    /**
     * Branch to work on
     */
    branch?: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/background/spawn"
}

export type BackgroundSpawnErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type BackgroundSpawnError = BackgroundSpawnErrors[keyof BackgroundSpawnErrors]

export type BackgroundSpawnResponses = {
  /**
   * Agent spawned successfully
   */
  200: {
    id: string
    parentSessionID: string
    sessionID: string
    sandboxID?: string
    status: "queued" | "initializing" | "running" | "completed" | "failed" | "cancelled"
    task: string
    createdAt: number
    startedAt?: number
    completedAt?: number
    error?: string
    output?: unknown
  }
}

export type BackgroundSpawnResponse = BackgroundSpawnResponses[keyof BackgroundSpawnResponses]

export type BackgroundGetData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/background/{id}"
}

export type BackgroundGetErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type BackgroundGetError = BackgroundGetErrors[keyof BackgroundGetErrors]

export type BackgroundGetResponses = {
  /**
   * Agent information
   */
  200: {
    id: string
    parentSessionID: string
    sessionID: string
    sandboxID?: string
    status: "queued" | "initializing" | "running" | "completed" | "failed" | "cancelled"
    task: string
    createdAt: number
    startedAt?: number
    completedAt?: number
    error?: string
    output?: unknown
  }
}

export type BackgroundGetResponse = BackgroundGetResponses[keyof BackgroundGetResponses]

export type BackgroundListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
    /**
     * Filter by parent session ID
     */
    parentSessionID?: string
  }
  url: "/background"
}

export type BackgroundListResponses = {
  /**
   * List of agents
   */
  200: {
    agents: Array<{
      id: string
      parentSessionID: string
      sessionID: string
      sandboxID?: string
      status: "queued" | "initializing" | "running" | "completed" | "failed" | "cancelled"
      task: string
      createdAt: number
      startedAt?: number
      completedAt?: number
      error?: string
      output?: unknown
    }>
    stats: {
      queued: number
      running: number
      completed: number
      failed: number
    }
  }
}

export type BackgroundListResponse = BackgroundListResponses[keyof BackgroundListResponses]

export type BackgroundCancelData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/background/{id}/cancel"
}

export type BackgroundCancelErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type BackgroundCancelError = BackgroundCancelErrors[keyof BackgroundCancelErrors]

export type BackgroundCancelResponses = {
  /**
   * Agent cancelled
   */
  200: {
    success: boolean
  }
}

export type BackgroundCancelResponse = BackgroundCancelResponses[keyof BackgroundCancelResponses]

export type BackgroundOutputData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/background/{id}/output"
}

export type BackgroundOutputErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type BackgroundOutputError = BackgroundOutputErrors[keyof BackgroundOutputErrors]

export type BackgroundOutputResponses = {
  /**
   * Agent output
   */
  200: {
    id: string
    status: "queued" | "initializing" | "running" | "completed" | "failed" | "cancelled"
    output?: unknown
    error?: string
  }
}

export type BackgroundOutputResponse = BackgroundOutputResponses[keyof BackgroundOutputResponses]

export type BackgroundEventsData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/background/{id}/events"
}

export type BackgroundEventsErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type BackgroundEventsError = BackgroundEventsErrors[keyof BackgroundEventsErrors]

export type BackgroundEventsResponses = {
  /**
   * Event stream
   */
  200: {
    type: "status" | "output" | "error" | "complete"
    agent?: {
      id: string
      parentSessionID: string
      sessionID: string
      sandboxID?: string
      status: "queued" | "initializing" | "running" | "completed" | "failed" | "cancelled"
      task: string
      createdAt: number
      startedAt?: number
      completedAt?: number
      error?: string
      output?: unknown
    }
    data?: unknown
  }
}

export type BackgroundEventsResponse = BackgroundEventsResponses[keyof BackgroundEventsResponses]

export type BackgroundStatsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/background/stats"
}

export type BackgroundStatsResponses = {
  /**
   * Scheduler statistics
   */
  200: {
    queued: number
    running: number
    completed: number
    failed: number
  }
}

export type BackgroundStatsResponse = BackgroundStatsResponses[keyof BackgroundStatsResponses]

export type MultiplayerListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/multiplayer"
}

export type MultiplayerListResponses = {
  /**
   * List of sessions
   */
  200: Array<{
    id: string
    sessionID: string
    sandboxID?: string
    users: Array<{
      id: string
      name: string
      email?: string
      avatar?: string
      color: string
      cursor?: {
        file?: string
        line?: number
        column?: number
      }
      joinedAt: number
    }>
    clients: Array<{
      id: string
      userID: string
      type: "web" | "slack" | "chrome" | "mobile" | "voice"
      connectedAt: number
      lastActivity: number
    }>
    activePrompt?: {
      id: string
      userID: string
      content: string
      startedAt: number
    }
    promptQueue: Array<{
      id: string
      userID: string
      content: string
      queuedAt: number
      priority: number
    }>
    state: {
      gitSyncStatus: "pending" | "syncing" | "synced" | "error"
      agentStatus: "idle" | "thinking" | "executing"
      editLock?: string
      version: number
    }
    createdAt: number
  }>
}

export type MultiplayerListResponse = MultiplayerListResponses[keyof MultiplayerListResponses]

export type MultiplayerCreateData = {
  body?: {
    sessionID: string
    sandboxID?: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/multiplayer"
}

export type MultiplayerCreateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type MultiplayerCreateError = MultiplayerCreateErrors[keyof MultiplayerCreateErrors]

export type MultiplayerCreateResponses = {
  /**
   * Session created successfully
   */
  200: {
    id: string
    sessionID: string
    sandboxID?: string
    users: Array<{
      id: string
      name: string
      email?: string
      avatar?: string
      color: string
      cursor?: {
        file?: string
        line?: number
        column?: number
      }
      joinedAt: number
    }>
    clients: Array<{
      id: string
      userID: string
      type: "web" | "slack" | "chrome" | "mobile" | "voice"
      connectedAt: number
      lastActivity: number
    }>
    activePrompt?: {
      id: string
      userID: string
      content: string
      startedAt: number
    }
    promptQueue: Array<{
      id: string
      userID: string
      content: string
      queuedAt: number
      priority: number
    }>
    state: {
      gitSyncStatus: "pending" | "syncing" | "synced" | "error"
      agentStatus: "idle" | "thinking" | "executing"
      editLock?: string
      version: number
    }
    createdAt: number
  }
}

export type MultiplayerCreateResponse = MultiplayerCreateResponses[keyof MultiplayerCreateResponses]

export type MultiplayerDeleteData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}"
}

export type MultiplayerDeleteErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerDeleteError = MultiplayerDeleteErrors[keyof MultiplayerDeleteErrors]

export type MultiplayerDeleteResponses = {
  /**
   * Session deleted
   */
  200: {
    success: boolean
  }
}

export type MultiplayerDeleteResponse = MultiplayerDeleteResponses[keyof MultiplayerDeleteResponses]

export type MultiplayerGetData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}"
}

export type MultiplayerGetErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerGetError = MultiplayerGetErrors[keyof MultiplayerGetErrors]

export type MultiplayerGetResponses = {
  /**
   * Session information
   */
  200: {
    id: string
    sessionID: string
    sandboxID?: string
    users: Array<{
      id: string
      name: string
      email?: string
      avatar?: string
      color: string
      cursor?: {
        file?: string
        line?: number
        column?: number
      }
      joinedAt: number
    }>
    clients: Array<{
      id: string
      userID: string
      type: "web" | "slack" | "chrome" | "mobile" | "voice"
      connectedAt: number
      lastActivity: number
    }>
    activePrompt?: {
      id: string
      userID: string
      content: string
      startedAt: number
    }
    promptQueue: Array<{
      id: string
      userID: string
      content: string
      queuedAt: number
      priority: number
    }>
    state: {
      gitSyncStatus: "pending" | "syncing" | "synced" | "error"
      agentStatus: "idle" | "thinking" | "executing"
      editLock?: string
      version: number
    }
    createdAt: number
  }
}

export type MultiplayerGetResponse = MultiplayerGetResponses[keyof MultiplayerGetResponses]

export type MultiplayerJoinData = {
  body?: {
    userID: string
    name: string
    email?: string
    avatar?: string
    color?: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/join"
}

export type MultiplayerJoinErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerJoinError = MultiplayerJoinErrors[keyof MultiplayerJoinErrors]

export type MultiplayerJoinResponses = {
  /**
   * Successfully joined
   */
  200: {
    id: string
    name: string
    email?: string
    avatar?: string
    color: string
    cursor?: {
      file?: string
      line?: number
      column?: number
    }
    joinedAt: number
  }
}

export type MultiplayerJoinResponse = MultiplayerJoinResponses[keyof MultiplayerJoinResponses]

export type MultiplayerLeaveData = {
  body?: {
    userID: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/leave"
}

export type MultiplayerLeaveErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerLeaveError = MultiplayerLeaveErrors[keyof MultiplayerLeaveErrors]

export type MultiplayerLeaveResponses = {
  /**
   * Successfully left
   */
  200: {
    success: boolean
  }
}

export type MultiplayerLeaveResponse = MultiplayerLeaveResponses[keyof MultiplayerLeaveResponses]

export type MultiplayerUpdateCursorData = {
  body?: {
    userID: string
    cursor: {
      file?: string
      line?: number
      column?: number
    }
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/cursor"
}

export type MultiplayerUpdateCursorErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerUpdateCursorError = MultiplayerUpdateCursorErrors[keyof MultiplayerUpdateCursorErrors]

export type MultiplayerUpdateCursorResponses = {
  /**
   * Cursor updated
   */
  200: {
    success: boolean
  }
}

export type MultiplayerUpdateCursorResponse = MultiplayerUpdateCursorResponses[keyof MultiplayerUpdateCursorResponses]

export type MultiplayerReleaseLockData = {
  body?: {
    userID: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/lock"
}

export type MultiplayerReleaseLockErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerReleaseLockError = MultiplayerReleaseLockErrors[keyof MultiplayerReleaseLockErrors]

export type MultiplayerReleaseLockResponses = {
  /**
   * Lock released
   */
  200: {
    success: boolean
  }
}

export type MultiplayerReleaseLockResponse = MultiplayerReleaseLockResponses[keyof MultiplayerReleaseLockResponses]

export type MultiplayerAcquireLockData = {
  body?: {
    userID: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/lock"
}

export type MultiplayerAcquireLockErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerAcquireLockError = MultiplayerAcquireLockErrors[keyof MultiplayerAcquireLockErrors]

export type MultiplayerAcquireLockResponses = {
  /**
   * Lock result
   */
  200: {
    success: boolean
    reason?: string
  }
}

export type MultiplayerAcquireLockResponse = MultiplayerAcquireLockResponses[keyof MultiplayerAcquireLockResponses]

export type MultiplayerConnectData = {
  body?: {
    userID: string
    type: "web" | "slack" | "chrome" | "mobile" | "voice"
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/connect"
}

export type MultiplayerConnectErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerConnectError = MultiplayerConnectErrors[keyof MultiplayerConnectErrors]

export type MultiplayerConnectResponses = {
  /**
   * Client connected
   */
  200: {
    id: string
    userID: string
    type: "web" | "slack" | "chrome" | "mobile" | "voice"
    connectedAt: number
    lastActivity: number
  }
}

export type MultiplayerConnectResponse = MultiplayerConnectResponses[keyof MultiplayerConnectResponses]

export type MultiplayerDisconnectData = {
  body?: {
    clientID: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/disconnect"
}

export type MultiplayerDisconnectErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerDisconnectError = MultiplayerDisconnectErrors[keyof MultiplayerDisconnectErrors]

export type MultiplayerDisconnectResponses = {
  /**
   * Client disconnected
   */
  200: {
    success: boolean
  }
}

export type MultiplayerDisconnectResponse = MultiplayerDisconnectResponses[keyof MultiplayerDisconnectResponses]

export type MultiplayerUsersData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/users"
}

export type MultiplayerUsersErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerUsersError = MultiplayerUsersErrors[keyof MultiplayerUsersErrors]

export type MultiplayerUsersResponses = {
  /**
   * List of users
   */
  200: Array<{
    id: string
    name: string
    email?: string
    avatar?: string
    color: string
    cursor?: {
      file?: string
      line?: number
      column?: number
    }
    joinedAt: number
  }>
}

export type MultiplayerUsersResponse = MultiplayerUsersResponses[keyof MultiplayerUsersResponses]

export type MultiplayerClientsData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/clients"
}

export type MultiplayerClientsErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerClientsError = MultiplayerClientsErrors[keyof MultiplayerClientsErrors]

export type MultiplayerClientsResponses = {
  /**
   * List of clients
   */
  200: Array<{
    id: string
    userID: string
    type: "web" | "slack" | "chrome" | "mobile" | "voice"
    connectedAt: number
    lastActivity: number
  }>
}

export type MultiplayerClientsResponse = MultiplayerClientsResponses[keyof MultiplayerClientsResponses]

export type MultiplayerUpdateStateData = {
  body?: {
    gitSyncStatus?: "pending" | "syncing" | "synced" | "error"
    agentStatus?: "idle" | "thinking" | "executing"
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/state"
}

export type MultiplayerUpdateStateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerUpdateStateError = MultiplayerUpdateStateErrors[keyof MultiplayerUpdateStateErrors]

export type MultiplayerUpdateStateResponses = {
  /**
   * State updated
   */
  200: {
    success: boolean
  }
}

export type MultiplayerUpdateStateResponse = MultiplayerUpdateStateResponses[keyof MultiplayerUpdateStateResponses]

export type MultiplayerQueuePromptData = {
  body?: {
    /**
     * ID of the user submitting the prompt
     */
    userID: string
    /**
     * The prompt content
     */
    content: string
    /**
     * Priority level (normal, high, urgent)
     */
    priority?: "normal" | "high" | "urgent"
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/prompt"
}

export type MultiplayerQueuePromptErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerQueuePromptError = MultiplayerQueuePromptErrors[keyof MultiplayerQueuePromptErrors]

export type MultiplayerQueuePromptResponses = {
  /**
   * Prompt queued
   */
  200: {
    id: string
    sessionID: string
    userID: string
    content: string
    status: "queued" | "executing" | "completed" | "cancelled"
    priority: "normal" | "high" | "urgent"
    createdAt: number
    startedAt?: number
    completedAt?: number
  }
}

export type MultiplayerQueuePromptResponse = MultiplayerQueuePromptResponses[keyof MultiplayerQueuePromptResponses]

export type MultiplayerGetPromptsData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/prompts"
}

export type MultiplayerGetPromptsErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerGetPromptsError = MultiplayerGetPromptsErrors[keyof MultiplayerGetPromptsErrors]

export type MultiplayerGetPromptsResponses = {
  /**
   * List of prompts
   */
  200: Array<{
    id: string
    sessionID: string
    userID: string
    content: string
    status: "queued" | "executing" | "completed" | "cancelled"
    priority: "normal" | "high" | "urgent"
    createdAt: number
    startedAt?: number
    completedAt?: number
  }>
}

export type MultiplayerGetPromptsResponse = MultiplayerGetPromptsResponses[keyof MultiplayerGetPromptsResponses]

export type MultiplayerCancelPromptData = {
  body?: {
    userID: string
  }
  path: {
    sessionID: string
    promptID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/prompt/{promptID}"
}

export type MultiplayerCancelPromptErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerCancelPromptError = MultiplayerCancelPromptErrors[keyof MultiplayerCancelPromptErrors]

export type MultiplayerCancelPromptResponses = {
  /**
   * Prompt cancelled
   */
  200: {
    success: boolean
  }
}

export type MultiplayerCancelPromptResponse = MultiplayerCancelPromptResponses[keyof MultiplayerCancelPromptResponses]

export type MultiplayerGetPromptData = {
  body?: never
  path: {
    sessionID: string
    promptID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/prompt/{promptID}"
}

export type MultiplayerGetPromptErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerGetPromptError = MultiplayerGetPromptErrors[keyof MultiplayerGetPromptErrors]

export type MultiplayerGetPromptResponses = {
  /**
   * Prompt information
   */
  200: {
    id: string
    sessionID: string
    userID: string
    content: string
    status: "queued" | "executing" | "completed" | "cancelled"
    priority: "normal" | "high" | "urgent"
    createdAt: number
    startedAt?: number
    completedAt?: number
  }
}

export type MultiplayerGetPromptResponse = MultiplayerGetPromptResponses[keyof MultiplayerGetPromptResponses]

export type MultiplayerReorderPromptData = {
  body?: {
    userID: string
    /**
     * New position in the queue (0-based)
     */
    newIndex: number
  }
  path: {
    sessionID: string
    promptID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/prompt/{promptID}/reorder"
}

export type MultiplayerReorderPromptErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerReorderPromptError = MultiplayerReorderPromptErrors[keyof MultiplayerReorderPromptErrors]

export type MultiplayerReorderPromptResponses = {
  /**
   * Prompt reordered
   */
  200: {
    success: boolean
  }
}

export type MultiplayerReorderPromptResponse =
  MultiplayerReorderPromptResponses[keyof MultiplayerReorderPromptResponses]

export type MultiplayerQueueStatusData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/queue/status"
}

export type MultiplayerQueueStatusErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerQueueStatusError = MultiplayerQueueStatusErrors[keyof MultiplayerQueueStatusErrors]

export type MultiplayerQueueStatusResponses = {
  /**
   * Queue status
   */
  200: {
    length: number
    hasExecuting: boolean
    isFull: boolean
  }
}

export type MultiplayerQueueStatusResponse = MultiplayerQueueStatusResponses[keyof MultiplayerQueueStatusResponses]

export type MultiplayerStartNextPromptData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/queue/start"
}

export type MultiplayerStartNextPromptErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerStartNextPromptError = MultiplayerStartNextPromptErrors[keyof MultiplayerStartNextPromptErrors]

export type MultiplayerStartNextPromptResponses = {
  /**
   * Prompt started or null if none available
   */
  200: {
    id: string
    sessionID: string
    userID: string
    content: string
    status: "queued" | "executing" | "completed" | "cancelled"
    priority: "normal" | "high" | "urgent"
    createdAt: number
    startedAt?: number
    completedAt?: number
  } | null
}

export type MultiplayerStartNextPromptResponse =
  MultiplayerStartNextPromptResponses[keyof MultiplayerStartNextPromptResponses]

export type MultiplayerCompletePromptData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/queue/complete"
}

export type MultiplayerCompletePromptErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerCompletePromptError = MultiplayerCompletePromptErrors[keyof MultiplayerCompletePromptErrors]

export type MultiplayerCompletePromptResponses = {
  /**
   * Completed prompt or null if none executing
   */
  200: {
    id: string
    sessionID: string
    userID: string
    content: string
    status: "queued" | "executing" | "completed" | "cancelled"
    priority: "normal" | "high" | "urgent"
    createdAt: number
    startedAt?: number
    completedAt?: number
  } | null
}

export type MultiplayerCompletePromptResponse =
  MultiplayerCompletePromptResponses[keyof MultiplayerCompletePromptResponses]

export type MultiplayerExecutingPromptData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/multiplayer/{sessionID}/queue/executing"
}

export type MultiplayerExecutingPromptErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerExecutingPromptError = MultiplayerExecutingPromptErrors[keyof MultiplayerExecutingPromptErrors]

export type MultiplayerExecutingPromptResponses = {
  /**
   * Executing prompt or null
   */
  200: {
    id: string
    sessionID: string
    userID: string
    content: string
    status: "queued" | "executing" | "completed" | "cancelled"
    priority: "normal" | "high" | "urgent"
    createdAt: number
    startedAt?: number
    completedAt?: number
  } | null
}

export type MultiplayerExecutingPromptResponse =
  MultiplayerExecutingPromptResponses[keyof MultiplayerExecutingPromptResponses]

export type MultiplayerWebsocketData = {
  body?: never
  path: {
    sessionID: string
  }
  query: {
    directory?: string
    /**
     * User ID for the WebSocket connection
     */
    userID: string
    /**
     * Client type (defaults to web)
     */
    clientType?: "web" | "slack" | "chrome" | "mobile" | "voice"
  }
  url: "/multiplayer/{sessionID}/ws"
}

export type MultiplayerWebsocketErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type MultiplayerWebsocketError = MultiplayerWebsocketErrors[keyof MultiplayerWebsocketErrors]

export type SandboxListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
    /**
     * Filter by project ID
     */
    projectID?: string
  }
  url: "/sandbox"
}

export type SandboxListResponses = {
  /**
   * List of sandboxes
   */
  200: Array<{
    id: string
    projectID: string
    status: "initializing" | "ready" | "running" | "suspended" | "terminated"
    provider: "modal" | "local" | "kubernetes"
    image: {
      id: string
      tag: string
      digest: string
      builtAt: number
    }
    git: {
      repo: string
      branch: string
      commit: string
      syncStatus: "pending" | "syncing" | "synced" | "error"
      syncedAt?: number
    }
    services: Array<{
      name: string
      status: "starting" | "running" | "stopped" | "error"
      port?: number
      url?: string
    }>
    network: {
      internalIP: string
      ports: {
        [key: string]: number
      }
      publicURL?: string
    }
    snapshot?: {
      id: string
      createdAt: number
    }
    time: {
      created: number
      ready?: number
      lastActivity: number
    }
  }>
}

export type SandboxListResponse = SandboxListResponses[keyof SandboxListResponses]

export type SandboxCreateData = {
  body?: {
    projectID: string
    repository: string
    branch?: string
    services?: Array<string>
    resources?: {
      cpu?: number
      memory?: number
      disk?: number
    }
    imageTag?: string
    snapshotID?: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/sandbox"
}

export type SandboxCreateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type SandboxCreateError = SandboxCreateErrors[keyof SandboxCreateErrors]

export type SandboxCreateResponses = {
  /**
   * Sandbox created successfully
   */
  200: {
    id: string
    projectID: string
    status: "initializing" | "ready" | "running" | "suspended" | "terminated"
    provider: "modal" | "local" | "kubernetes"
    image: {
      id: string
      tag: string
      digest: string
      builtAt: number
    }
    git: {
      repo: string
      branch: string
      commit: string
      syncStatus: "pending" | "syncing" | "synced" | "error"
      syncedAt?: number
    }
    services: Array<{
      name: string
      status: "starting" | "running" | "stopped" | "error"
      port?: number
      url?: string
    }>
    network: {
      internalIP: string
      ports: {
        [key: string]: number
      }
      publicURL?: string
    }
    snapshot?: {
      id: string
      createdAt: number
    }
    time: {
      created: number
      ready?: number
      lastActivity: number
    }
  }
}

export type SandboxCreateResponse = SandboxCreateResponses[keyof SandboxCreateResponses]

export type SandboxGetData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}"
}

export type SandboxGetErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxGetError = SandboxGetErrors[keyof SandboxGetErrors]

export type SandboxGetResponses = {
  /**
   * Sandbox information
   */
  200: {
    id: string
    projectID: string
    status: "initializing" | "ready" | "running" | "suspended" | "terminated"
    provider: "modal" | "local" | "kubernetes"
    image: {
      id: string
      tag: string
      digest: string
      builtAt: number
    }
    git: {
      repo: string
      branch: string
      commit: string
      syncStatus: "pending" | "syncing" | "synced" | "error"
      syncedAt?: number
    }
    services: Array<{
      name: string
      status: "starting" | "running" | "stopped" | "error"
      port?: number
      url?: string
    }>
    network: {
      internalIP: string
      ports: {
        [key: string]: number
      }
      publicURL?: string
    }
    snapshot?: {
      id: string
      createdAt: number
    }
    time: {
      created: number
      ready?: number
      lastActivity: number
    }
  }
}

export type SandboxGetResponse = SandboxGetResponses[keyof SandboxGetResponses]

export type SandboxStartData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/start"
}

export type SandboxStartErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxStartError = SandboxStartErrors[keyof SandboxStartErrors]

export type SandboxStartResponses = {
  /**
   * Sandbox started
   */
  200: {
    success: boolean
  }
}

export type SandboxStartResponse = SandboxStartResponses[keyof SandboxStartResponses]

export type SandboxStopData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/stop"
}

export type SandboxStopErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxStopError = SandboxStopErrors[keyof SandboxStopErrors]

export type SandboxStopResponses = {
  /**
   * Sandbox stopped
   */
  200: {
    success: boolean
  }
}

export type SandboxStopResponse = SandboxStopResponses[keyof SandboxStopResponses]

export type SandboxTerminateData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/terminate"
}

export type SandboxTerminateErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxTerminateError = SandboxTerminateErrors[keyof SandboxTerminateErrors]

export type SandboxTerminateResponses = {
  /**
   * Sandbox terminated
   */
  200: {
    success: boolean
  }
}

export type SandboxTerminateResponse = SandboxTerminateResponses[keyof SandboxTerminateResponses]

export type SandboxSnapshotData = {
  body?: {
    /**
     * Session ID that owns this sandbox
     */
    sessionID: string
    /**
     * Current git commit hash
     */
    gitCommit: string
    /**
     * Whether there are uncommitted changes
     */
    hasUncommittedChanges?: boolean
  }
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/snapshot"
}

export type SandboxSnapshotErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxSnapshotError = SandboxSnapshotErrors[keyof SandboxSnapshotErrors]

export type SandboxSnapshotResponses = {
  /**
   * Snapshot created
   */
  200: {
    snapshotID: string
    createdAt: number
  }
}

export type SandboxSnapshotResponse = SandboxSnapshotResponses[keyof SandboxSnapshotResponses]

export type SandboxRestoreData = {
  body?: {
    /**
     * Session ID to restore snapshot for
     */
    sessionID: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/sandbox/restore"
}

export type SandboxRestoreErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxRestoreError = SandboxRestoreErrors[keyof SandboxRestoreErrors]

export type SandboxRestoreResponses = {
  /**
   * Sandbox restored
   */
  200: {
    id: string
    projectID: string
    status: "initializing" | "ready" | "running" | "suspended" | "terminated"
    provider: "modal" | "local" | "kubernetes"
    image: {
      id: string
      tag: string
      digest: string
      builtAt: number
    }
    git: {
      repo: string
      branch: string
      commit: string
      syncStatus: "pending" | "syncing" | "synced" | "error"
      syncedAt?: number
    }
    services: Array<{
      name: string
      status: "starting" | "running" | "stopped" | "error"
      port?: number
      url?: string
    }>
    network: {
      internalIP: string
      ports: {
        [key: string]: number
      }
      publicURL?: string
    }
    snapshot?: {
      id: string
      createdAt: number
    }
    time: {
      created: number
      ready?: number
      lastActivity: number
    }
  }
}

export type SandboxRestoreResponse = SandboxRestoreResponses[keyof SandboxRestoreResponses]

export type SandboxListSnapshotsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/sandbox/snapshots"
}

export type SandboxListSnapshotsResponses = {
  /**
   * List of snapshots
   */
  200: Array<{
    id: string
    sandboxID: string
    expiresAt: number
  }>
}

export type SandboxListSnapshotsResponse = SandboxListSnapshotsResponses[keyof SandboxListSnapshotsResponses]

export type SandboxDeleteSnapshotData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/snapshots/{id}"
}

export type SandboxDeleteSnapshotErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxDeleteSnapshotError = SandboxDeleteSnapshotErrors[keyof SandboxDeleteSnapshotErrors]

export type SandboxDeleteSnapshotResponses = {
  /**
   * Snapshot deleted
   */
  200: {
    success: boolean
  }
}

export type SandboxDeleteSnapshotResponse = SandboxDeleteSnapshotResponses[keyof SandboxDeleteSnapshotResponses]

export type SandboxExecData = {
  body?: {
    /**
     * Command and arguments
     */
    command: Array<string>
    /**
     * Working directory
     */
    cwd?: string
    /**
     * Environment variables
     */
    env?: {
      [key: string]: string
    }
    /**
     * Timeout in milliseconds
     */
    timeout?: number
  }
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/exec"
}

export type SandboxExecErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxExecError = SandboxExecErrors[keyof SandboxExecErrors]

export type SandboxExecResponses = {
  /**
   * Command result
   */
  200: {
    exitCode: number
    stdout: string
    stderr: string
    duration: number
  }
}

export type SandboxExecResponse = SandboxExecResponses[keyof SandboxExecResponses]

export type SandboxLogsData = {
  body?: never
  path: {
    id: string
    service: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/logs/{service}"
}

export type SandboxLogsErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxLogsError = SandboxLogsErrors[keyof SandboxLogsErrors]

export type SandboxLogsResponses = {
  /**
   * Log stream
   */
  200: {
    type: "log"
    data: string
  }
}

export type SandboxLogsResponse = SandboxLogsResponses[keyof SandboxLogsResponses]

export type SandboxGitStatusData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/git"
}

export type SandboxGitStatusErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxGitStatusError = SandboxGitStatusErrors[keyof SandboxGitStatusErrors]

export type SandboxGitStatusResponses = {
  /**
   * Git status
   */
  200: {
    repo: string
    branch: string
    commit: string
    syncStatus: "pending" | "syncing" | "synced" | "error"
    syncedAt?: number
  }
}

export type SandboxGitStatusResponse = SandboxGitStatusResponses[keyof SandboxGitStatusResponses]

export type SandboxGitSyncData = {
  body?: never
  path: {
    id: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{id}/git/sync"
}

export type SandboxGitSyncErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SandboxGitSyncError = SandboxGitSyncErrors[keyof SandboxGitSyncErrors]

export type SandboxGitSyncResponses = {
  /**
   * Git sync triggered
   */
  200: {
    success: boolean
  }
}

export type SandboxGitSyncResponse = SandboxGitSyncResponses[keyof SandboxGitSyncResponses]

export type SandboxPoolStatsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/sandbox/pool/stats"
}

export type SandboxPoolStatsResponses = {
  /**
   * Pool statistics
   */
  200: {
    available: number
    total: number
    warming: number
  }
}

export type SandboxPoolStatsResponse = SandboxPoolStatsResponses[keyof SandboxPoolStatsResponses]

export type SandboxPoolClaimData = {
  body?: {
    /**
     * Repository URL to claim sandbox for
     */
    repository: string
    /**
     * Project ID to claim sandbox for
     */
    projectID: string
    /**
     * Optional specific image tag
     */
    imageTag?: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/sandbox/pool/claim"
}

export type SandboxPoolClaimResponses = {
  /**
   * Claimed sandbox or null if none available
   */
  200: {
    id: string
    projectID: string
    status: "initializing" | "ready" | "running" | "suspended" | "terminated"
    provider: "modal" | "local" | "kubernetes"
    image: {
      id: string
      tag: string
      digest: string
      builtAt: number
    }
    git: {
      repo: string
      branch: string
      commit: string
      syncStatus: "pending" | "syncing" | "synced" | "error"
      syncedAt?: number
    }
    services: Array<{
      name: string
      status: "starting" | "running" | "stopped" | "error"
      port?: number
      url?: string
    }>
    network: {
      internalIP: string
      ports: {
        [key: string]: number
      }
      publicURL?: string
    }
    snapshot?: {
      id: string
      createdAt: number
    }
    time: {
      created: number
      ready?: number
      lastActivity: number
    }
  } | null
}

export type SandboxPoolClaimResponse = SandboxPoolClaimResponses[keyof SandboxPoolClaimResponses]

export type SandboxPoolTypingData = {
  body?: {
    /**
     * Repository URL to warm sandbox for
     */
    repository: string
    /**
     * Project ID to warm sandbox for
     */
    projectID: string
    /**
     * Optional session ID for hook context
     */
    sessionID?: string
    /**
     * Optional partial prompt for warmup hints
     */
    partialPrompt?: string
    /**
     * Optional specific image tag
     */
    imageTag?: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/sandbox/pool/typing"
}

export type SandboxPoolTypingResponses = {
  /**
   * Warmup triggered
   */
  200: {
    success: boolean
  }
}

export type SandboxPoolTypingResponse = SandboxPoolTypingResponses[keyof SandboxPoolTypingResponses]

export type SkillsListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/skills"
}

export type SkillsListResponses = {
  /**
   * List of available skills
   */
  200: Array<{
    name: string
    description: string
    location: string
  }>
}

export type SkillsListResponse = SkillsListResponses[keyof SkillsListResponses]

export type SkillsGetData = {
  body?: never
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/skills/{name}"
}

export type SkillsGetErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type SkillsGetError = SkillsGetErrors[keyof SkillsGetErrors]

export type SkillsGetResponses = {
  /**
   * Skill details
   */
  200: {
    name: string
    description: string
    location: string
    content: string
  }
}

export type SkillsGetResponse = SkillsGetResponses[keyof SkillsGetResponses]

export type StatsGetData = {
  body?: never
  path?: never
  query?: {
    directory?: string
    /**
     * Number of days to include (default: all time)
     */
    days?: number
    /**
     * Filter by project ID
     */
    project?: string
  }
  url: "/stats"
}

export type StatsGetResponses = {
  /**
   * Session statistics
   */
  200: {
    totalSessions: number
    totalMessages: number
    totalCost: number
    totalTokens: {
      input: number
      output: number
      reasoning: number
      cache: {
        read: number
        write: number
      }
    }
    toolUsage: {
      [key: string]: number
    }
    modelUsage: {
      [key: string]: {
        messages: number
        tokens: {
          input: number
          output: number
        }
        cost: number
      }
    }
    dateRange: {
      earliest: number
      latest: number
    }
    days: number
    costPerDay: number
    tokensPerSession: number
    medianTokensPerSession: number
  }
}

export type StatsGetResponse = StatsGetResponses[keyof StatsGetResponses]

export type StatsLiveData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/stats/live"
}

export type StatsLiveResponses = {
  /**
   * Live metrics
   */
  200: {
    activeSessions: number
    totalSessions: number
    totalMessages: number
    recentCost: number
  }
}

export type StatsLiveResponse = StatsLiveResponses[keyof StatsLiveResponses]

export type StatsHistoricalData = {
  body?: never
  path?: never
  query?: {
    directory?: string
    /**
     * Time period
     */
    period?: "day" | "week" | "month" | "quarter"
    /**
     * Filter by project ID
     */
    project?: string
  }
  url: "/stats/historical"
}

export type StatsHistoricalResponses = {
  /**
   * Historical metrics
   */
  200: {
    totalSessions: number
    totalMessages: number
    totalCost: number
    totalTokens: {
      input: number
      output: number
      reasoning: number
      cache: {
        read: number
        write: number
      }
    }
    toolUsage: {
      [key: string]: number
    }
    modelUsage: {
      [key: string]: {
        messages: number
        tokens: {
          input: number
          output: number
        }
        cost: number
      }
    }
    dateRange: {
      earliest: number
      latest: number
    }
    days: number
    costPerDay: number
    tokensPerSession: number
    medianTokensPerSession: number
  }
}

export type StatsHistoricalResponse = StatsHistoricalResponses[keyof StatsHistoricalResponses]

export type VoiceStartData = {
  body?: {
    /**
     * Language code for recognition (e.g., 'en-US')
     */
    language?: string
    /**
     * Whether to use continuous recognition
     */
    continuous?: boolean
    /**
     * Whether to return interim results
     */
    interimResults?: boolean
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/voice/start"
}

export type VoiceStartErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type VoiceStartError = VoiceStartErrors[keyof VoiceStartErrors]

export type VoiceStartResponses = {
  /**
   * Voice recognition started
   */
  200: {
    sessionID: string
    status: "idle" | "listening" | "processing" | "error"
    language?: string
    startedAt?: number
    lastActivityAt?: number
    error?: string
  }
}

export type VoiceStartResponse = VoiceStartResponses[keyof VoiceStartResponses]

export type VoiceStopData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/voice/stop"
}

export type VoiceStopErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type VoiceStopError = VoiceStopErrors[keyof VoiceStopErrors]

export type VoiceStopResponses = {
  /**
   * Voice recognition stopped
   */
  200: {
    sessionID: string
    status: "idle" | "listening" | "processing" | "error"
    language?: string
    startedAt?: number
    lastActivityAt?: number
    error?: string
  }
}

export type VoiceStopResponse = VoiceStopResponses[keyof VoiceStopResponses]

export type VoiceStatusData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/voice/status"
}

export type VoiceStatusErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type VoiceStatusError = VoiceStatusErrors[keyof VoiceStatusErrors]

export type VoiceStatusResponses = {
  /**
   * Voice recognition status
   */
  200: {
    sessionID: string
    status: "idle" | "listening" | "processing" | "error"
    language?: string
    startedAt?: number
    lastActivityAt?: number
    error?: string
  }
}

export type VoiceStatusResponse = VoiceStatusResponses[keyof VoiceStatusResponses]

export type VoiceSendData = {
  body?: {
    /**
     * Base64-encoded audio data
     */
    audio: string
    /**
     * MIME type of the audio (default: audio/webm)
     */
    mimeType?: string
    /**
     * Minimum confidence to auto-send (default: 0.5)
     */
    confidenceThreshold?: number
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/voice"
}

export type VoiceSendErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type VoiceSendError = VoiceSendErrors[keyof VoiceSendErrors]

export type VoiceSendResponses = {
  /**
   * Voice prompt processed
   */
  200: {
    transcript: {
      text: string
      isFinal: boolean
      confidence: number
      language?: string
    }
    /**
     * Whether the transcript meets criteria to be sent as a prompt
     */
    shouldSend: boolean
  }
}

export type VoiceSendResponse = VoiceSendResponses[keyof VoiceSendResponses]

export type DesktopGetData = {
  body?: never
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/desktop"
}

export type DesktopGetErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type DesktopGetError = DesktopGetErrors[keyof DesktopGetErrors]

export type DesktopGetResponses = {
  /**
   * Desktop information
   */
  200: {
    sandboxID: string
    status: "stopped" | "starting" | "running" | "stopping" | "error"
    vncUrl?: string
    vncPort?: number
    resolution?: {
      width?: number
      height?: number
    }
    startedAt?: number
    error?: string
  }
}

export type DesktopGetResponse = DesktopGetResponses[keyof DesktopGetResponses]

export type DesktopStartData = {
  body?: {
    /**
     * Desktop width in pixels (default: 1280)
     */
    width?: number
    /**
     * Desktop height in pixels (default: 720)
     */
    height?: number
  }
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/desktop/start"
}

export type DesktopStartErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type DesktopStartError = DesktopStartErrors[keyof DesktopStartErrors]

export type DesktopStartResponses = {
  /**
   * Desktop started
   */
  200: {
    sandboxID: string
    status: "stopped" | "starting" | "running" | "stopping" | "error"
    vncUrl?: string
    vncPort?: number
    resolution?: {
      width?: number
      height?: number
    }
    startedAt?: number
    error?: string
  }
}

export type DesktopStartResponse = DesktopStartResponses[keyof DesktopStartResponses]

export type DesktopStopData = {
  body?: never
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/desktop/stop"
}

export type DesktopStopErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type DesktopStopError = DesktopStopErrors[keyof DesktopStopErrors]

export type DesktopStopResponses = {
  /**
   * Desktop stopped
   */
  200: {
    sandboxID: string
    status: "stopped" | "starting" | "running" | "stopping" | "error"
    vncUrl?: string
    vncPort?: number
    resolution?: {
      width?: number
      height?: number
    }
    startedAt?: number
    error?: string
  }
}

export type DesktopStopResponse = DesktopStopResponses[keyof DesktopStopResponses]

export type DesktopScreenshotData = {
  body?: never
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/desktop/screenshot"
}

export type DesktopScreenshotErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type DesktopScreenshotError = DesktopScreenshotErrors[keyof DesktopScreenshotErrors]

export type DesktopScreenshotResponses = {
  /**
   * Screenshot captured
   */
  200: {
    sandboxID: string
    /**
     * Base64-encoded PNG image data
     */
    data: string
    mimeType: "image/png"
    width: number
    height: number
    capturedAt: number
  }
}

export type DesktopScreenshotResponse = DesktopScreenshotResponses[keyof DesktopScreenshotResponses]

export type DesktopWsData = {
  body?: never
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/desktop/ws"
}

export type DesktopWsErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type DesktopWsError = DesktopWsErrors[keyof DesktopWsErrors]

export type EditorGetData = {
  body?: never
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
    /**
     * If 'true', redirect to editor URL instead of returning JSON
     */
    redirect?: string
    /**
     * If 'true', automatically start editor if not running
     */
    autoStart?: string
  }
  url: "/sandbox/{sandboxID}/editor"
}

export type EditorGetErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type EditorGetError = EditorGetErrors[keyof EditorGetErrors]

export type EditorGetResponses = {
  /**
   * Editor information
   */
  200: {
    sandboxID: string
    type: "code-server" | "openvscode-server"
    status: "stopped" | "starting" | "running" | "stopping" | "error"
    url?: string
    port?: number
    startedAt?: number
    error?: string
  }
}

export type EditorGetResponse = EditorGetResponses[keyof EditorGetResponses]

export type EditorStartData = {
  body?: {
    /**
     * Editor type (default: code-server)
     */
    type?: "code-server" | "openvscode-server"
    /**
     * Port to run on (default: 8080)
     */
    port?: number
  }
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/editor/start"
}

export type EditorStartErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type EditorStartError = EditorStartErrors[keyof EditorStartErrors]

export type EditorStartResponses = {
  /**
   * Editor started
   */
  200: {
    sandboxID: string
    type: "code-server" | "openvscode-server"
    status: "stopped" | "starting" | "running" | "stopping" | "error"
    url?: string
    port?: number
    startedAt?: number
    error?: string
  }
}

export type EditorStartResponse = EditorStartResponses[keyof EditorStartResponses]

export type EditorStopData = {
  body?: never
  path: {
    sandboxID: string
  }
  query?: {
    directory?: string
  }
  url: "/sandbox/{sandboxID}/editor/stop"
}

export type EditorStopErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type EditorStopError = EditorStopErrors[keyof EditorStopErrors]

export type EditorStopResponses = {
  /**
   * Editor stopped
   */
  200: {
    sandboxID: string
    type: "code-server" | "openvscode-server"
    status: "stopped" | "starting" | "running" | "stopping" | "error"
    url?: string
    port?: number
    startedAt?: number
    error?: string
  }
}

export type EditorStopResponse = EditorStopResponses[keyof EditorStopResponses]

export type PrSessionListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/pr-session"
}

export type PrSessionListResponses = {
  /**
   * List of PR sessions
   */
  200: Array<{
    prNumber: number
    sessionID: string
    repository: string
    title: string
    author: string
    baseBranch: string
    headBranch: string
    status: "open" | "closed" | "merged"
    comments: Array<{
      id: string
      prNumber: number
      author: string
      body: string
      path?: string
      line?: number
      status: "pending" | "addressed" | "rejected" | "outdated"
      createdAt: number
      addressedAt?: number
      response?: string
    }>
    createdAt: number
    updatedAt: number
  }>
}

export type PrSessionListResponse = PrSessionListResponses[keyof PrSessionListResponses]

export type PrSessionCreateData = {
  body?: {
    prNumber: number
    /**
     * Repository in owner/repo format
     */
    repository: string
    /**
     * Existing session ID to associate, or create new
     */
    sessionID?: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/pr-session"
}

export type PrSessionCreateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type PrSessionCreateError = PrSessionCreateErrors[keyof PrSessionCreateErrors]

export type PrSessionCreateResponses = {
  /**
   * PR session created
   */
  200: {
    prNumber: number
    sessionID: string
    repository: string
    title: string
    author: string
    baseBranch: string
    headBranch: string
    status: "open" | "closed" | "merged"
    comments: Array<{
      id: string
      prNumber: number
      author: string
      body: string
      path?: string
      line?: number
      status: "pending" | "addressed" | "rejected" | "outdated"
      createdAt: number
      addressedAt?: number
      response?: string
    }>
    createdAt: number
    updatedAt: number
  }
}

export type PrSessionCreateResponse = PrSessionCreateResponses[keyof PrSessionCreateResponses]

export type PrSessionDeleteData = {
  body?: never
  path: {
    prNumber: string
  }
  query?: {
    directory?: string
  }
  url: "/pr-session/{prNumber}"
}

export type PrSessionDeleteErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PrSessionDeleteError = PrSessionDeleteErrors[keyof PrSessionDeleteErrors]

export type PrSessionDeleteResponses = {
  /**
   * PR session deleted
   */
  200: {
    success: boolean
  }
}

export type PrSessionDeleteResponse = PrSessionDeleteResponses[keyof PrSessionDeleteResponses]

export type PrSessionGetData = {
  body?: never
  path: {
    prNumber: string
  }
  query?: {
    directory?: string
  }
  url: "/pr-session/{prNumber}"
}

export type PrSessionGetErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PrSessionGetError = PrSessionGetErrors[keyof PrSessionGetErrors]

export type PrSessionGetResponses = {
  /**
   * PR session information
   */
  200: {
    prNumber: number
    sessionID: string
    repository: string
    title: string
    author: string
    baseBranch: string
    headBranch: string
    status: "open" | "closed" | "merged"
    comments: Array<{
      id: string
      prNumber: number
      author: string
      body: string
      path?: string
      line?: number
      status: "pending" | "addressed" | "rejected" | "outdated"
      createdAt: number
      addressedAt?: number
      response?: string
    }>
    createdAt: number
    updatedAt: number
  }
}

export type PrSessionGetResponse = PrSessionGetResponses[keyof PrSessionGetResponses]

export type PrSessionListCommentsData = {
  body?: never
  path: {
    prNumber: string
  }
  query?: {
    directory?: string
    /**
     * Filter by comment status
     */
    status?: "pending" | "addressed" | "rejected" | "outdated"
  }
  url: "/pr-session/{prNumber}/comments"
}

export type PrSessionListCommentsErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PrSessionListCommentsError = PrSessionListCommentsErrors[keyof PrSessionListCommentsErrors]

export type PrSessionListCommentsResponses = {
  /**
   * List of comments
   */
  200: Array<{
    id: string
    prNumber: number
    author: string
    body: string
    path?: string
    line?: number
    status: "pending" | "addressed" | "rejected" | "outdated"
    createdAt: number
    addressedAt?: number
    response?: string
  }>
}

export type PrSessionListCommentsResponse = PrSessionListCommentsResponses[keyof PrSessionListCommentsResponses]

export type PrSessionRespondData = {
  body?: {
    commentID: string
    response: string
    status?: "pending" | "addressed" | "rejected" | "outdated"
  }
  path: {
    prNumber: string
  }
  query?: {
    directory?: string
  }
  url: "/pr-session/{prNumber}/respond"
}

export type PrSessionRespondErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PrSessionRespondError = PrSessionRespondErrors[keyof PrSessionRespondErrors]

export type PrSessionRespondResponses = {
  /**
   * Comment updated
   */
  200: {
    id: string
    prNumber: number
    author: string
    body: string
    path?: string
    line?: number
    status: "pending" | "addressed" | "rejected" | "outdated"
    createdAt: number
    addressedAt?: number
    response?: string
  }
}

export type PrSessionRespondResponse = PrSessionRespondResponses[keyof PrSessionRespondResponses]

export type WebhookGithubData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/webhook/github"
}

export type WebhookGithubErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type WebhookGithubError = WebhookGithubErrors[keyof WebhookGithubErrors]

export type WebhookGithubResponses = {
  /**
   * Webhook received
   */
  200: {
    received: boolean
    event:
      | "pull_request"
      | "pull_request_review"
      | "pull_request_review_comment"
      | "issue_comment"
      | "push"
      | "check_run"
      | "check_suite"
      | "workflow_run"
      | "ping"
    action?: string
    repository?: string
    handled: boolean
  }
}

export type WebhookGithubResponse = WebhookGithubResponses[keyof WebhookGithubResponses]

export type WebhookSlackEventsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/webhook/slack/events"
}

export type WebhookSlackEventsErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type WebhookSlackEventsError = WebhookSlackEventsErrors[keyof WebhookSlackEventsErrors]

export type WebhookSlackEventsResponses = {
  /**
   * Event received
   */
  200:
    | {
        received: boolean
        type: string
        challenge?: string
        handled: boolean
      }
    | {
        challenge: string
      }
}

export type WebhookSlackEventsResponse = WebhookSlackEventsResponses[keyof WebhookSlackEventsResponses]

export type WebhookSlackInteractionsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/webhook/slack/interactions"
}

export type WebhookSlackInteractionsErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type WebhookSlackInteractionsError = WebhookSlackInteractionsErrors[keyof WebhookSlackInteractionsErrors]

export type WebhookSlackInteractionsResponses = {
  /**
   * Interaction received
   */
  200: {
    received: boolean
    type: string
    handled: boolean
    response?: unknown
  }
}

export type WebhookSlackInteractionsResponse =
  WebhookSlackInteractionsResponses[keyof WebhookSlackInteractionsResponses]

export type PtyListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/pty"
}

export type PtyListResponses = {
  /**
   * List of sessions
   */
  200: Array<Pty>
}

export type PtyListResponse = PtyListResponses[keyof PtyListResponses]

export type PtyCreateData = {
  body?: {
    command?: string
    args?: Array<string>
    cwd?: string
    title?: string
    env?: {
      [key: string]: string
    }
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/pty"
}

export type PtyCreateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type PtyCreateError = PtyCreateErrors[keyof PtyCreateErrors]

export type PtyCreateResponses = {
  /**
   * Created session
   */
  200: Pty
}

export type PtyCreateResponse = PtyCreateResponses[keyof PtyCreateResponses]

export type PtyRemoveData = {
  body?: never
  path: {
    ptyID: string
  }
  query?: {
    directory?: string
  }
  url: "/pty/{ptyID}"
}

export type PtyRemoveErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type PtyRemoveError = PtyRemoveErrors[keyof PtyRemoveErrors]

export type PtyRemoveResponses = {
  /**
   * Session removed
   */
  200: boolean
}

export type PtyRemoveResponse = PtyRemoveResponses[keyof PtyRemoveResponses]

export type PtyGetData = {
  body?: never
  path: {
    ptyID: string
  }
  query?: {
    directory?: string
  }
  url: "/pty/{ptyID}"
}

export type PtyGetErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type PtyGetError = PtyGetErrors[keyof PtyGetErrors]

export type PtyGetResponses = {
  /**
   * Session info
   */
  200: Pty
}

export type PtyGetResponse = PtyGetResponses[keyof PtyGetResponses]

export type PtyUpdateData = {
  body?: {
    title?: string
    size?: {
      rows: number
      cols: number
    }
  }
  path: {
    ptyID: string
  }
  query?: {
    directory?: string
  }
  url: "/pty/{ptyID}"
}

export type PtyUpdateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type PtyUpdateError = PtyUpdateErrors[keyof PtyUpdateErrors]

export type PtyUpdateResponses = {
  /**
   * Updated session
   */
  200: Pty
}

export type PtyUpdateResponse = PtyUpdateResponses[keyof PtyUpdateResponses]

export type PtyConnectData = {
  body?: never
  path: {
    ptyID: string
  }
  query?: {
    directory?: string
  }
  url: "/pty/{ptyID}/connect"
}

export type PtyConnectErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type PtyConnectError = PtyConnectErrors[keyof PtyConnectErrors]

export type PtyConnectResponses = {
  /**
   * Connected session
   */
  200: boolean
}

export type PtyConnectResponse = PtyConnectResponses[keyof PtyConnectResponses]

export type ConfigGetData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/config"
}

export type ConfigGetResponses = {
  /**
   * Get config info
   */
  200: Config
}

export type ConfigGetResponse = ConfigGetResponses[keyof ConfigGetResponses]

export type ConfigUpdateData = {
  body?: Config
  path?: never
  query?: {
    directory?: string
  }
  url: "/config"
}

export type ConfigUpdateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type ConfigUpdateError = ConfigUpdateErrors[keyof ConfigUpdateErrors]

export type ConfigUpdateResponses = {
  /**
   * Successfully updated config
   */
  200: Config
}

export type ConfigUpdateResponse = ConfigUpdateResponses[keyof ConfigUpdateResponses]

export type ToolIdsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/experimental/tool/ids"
}

export type ToolIdsErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type ToolIdsError = ToolIdsErrors[keyof ToolIdsErrors]

export type ToolIdsResponses = {
  /**
   * Tool IDs
   */
  200: ToolIds
}

export type ToolIdsResponse = ToolIdsResponses[keyof ToolIdsResponses]

export type ToolListData = {
  body?: never
  path?: never
  query: {
    directory?: string
    provider: string
    model: string
  }
  url: "/experimental/tool"
}

export type ToolListErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type ToolListError = ToolListErrors[keyof ToolListErrors]

export type ToolListResponses = {
  /**
   * Tools
   */
  200: ToolList
}

export type ToolListResponse = ToolListResponses[keyof ToolListResponses]

export type InstanceDisposeData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/instance/dispose"
}

export type InstanceDisposeResponses = {
  /**
   * Instance disposed
   */
  200: boolean
}

export type InstanceDisposeResponse = InstanceDisposeResponses[keyof InstanceDisposeResponses]

export type PathGetData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/path"
}

export type PathGetResponses = {
  /**
   * Path
   */
  200: Path
}

export type PathGetResponse = PathGetResponses[keyof PathGetResponses]

export type WorktreeListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/experimental/worktree"
}

export type WorktreeListResponses = {
  /**
   * List of worktree directories
   */
  200: Array<string>
}

export type WorktreeListResponse = WorktreeListResponses[keyof WorktreeListResponses]

export type WorktreeCreateData = {
  body?: WorktreeCreateInput
  path?: never
  query?: {
    directory?: string
  }
  url: "/experimental/worktree"
}

export type WorktreeCreateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type WorktreeCreateError = WorktreeCreateErrors[keyof WorktreeCreateErrors]

export type WorktreeCreateResponses = {
  /**
   * Worktree created
   */
  200: Worktree
}

export type WorktreeCreateResponse = WorktreeCreateResponses[keyof WorktreeCreateResponses]

export type VcsGetData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/vcs"
}

export type VcsGetResponses = {
  /**
   * VCS info
   */
  200: VcsInfo
}

export type VcsGetResponse = VcsGetResponses[keyof VcsGetResponses]

export type SessionListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
    /**
     * Filter sessions updated on or after this timestamp (milliseconds since epoch)
     */
    start?: number
    /**
     * Filter sessions by title (case-insensitive)
     */
    search?: string
    /**
     * Maximum number of sessions to return
     */
    limit?: number
  }
  url: "/session"
}

export type SessionListResponses = {
  /**
   * List of sessions
   */
  200: Array<Session>
}

export type SessionListResponse = SessionListResponses[keyof SessionListResponses]

export type SessionCreateData = {
  body?: {
    parentID?: string
    title?: string
    permission?: PermissionRuleset
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/session"
}

export type SessionCreateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type SessionCreateError = SessionCreateErrors[keyof SessionCreateErrors]

export type SessionCreateResponses = {
  /**
   * Successfully created session
   */
  200: Session
}

export type SessionCreateResponse = SessionCreateResponses[keyof SessionCreateResponses]

export type SessionStatusData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/session/status"
}

export type SessionStatusErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type SessionStatusError = SessionStatusErrors[keyof SessionStatusErrors]

export type SessionStatusResponses = {
  /**
   * Get session status
   */
  200: {
    [key: string]: SessionStatus
  }
}

export type SessionStatusResponse = SessionStatusResponses[keyof SessionStatusResponses]

export type SessionDeleteData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}"
}

export type SessionDeleteErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionDeleteError = SessionDeleteErrors[keyof SessionDeleteErrors]

export type SessionDeleteResponses = {
  /**
   * Successfully deleted session
   */
  200: boolean
}

export type SessionDeleteResponse = SessionDeleteResponses[keyof SessionDeleteResponses]

export type SessionGetData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}"
}

export type SessionGetErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionGetError = SessionGetErrors[keyof SessionGetErrors]

export type SessionGetResponses = {
  /**
   * Get session
   */
  200: Session
}

export type SessionGetResponse = SessionGetResponses[keyof SessionGetResponses]

export type SessionUpdateData = {
  body?: {
    title?: string
    time?: {
      archived?: number
    }
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}"
}

export type SessionUpdateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionUpdateError = SessionUpdateErrors[keyof SessionUpdateErrors]

export type SessionUpdateResponses = {
  /**
   * Successfully updated session
   */
  200: Session
}

export type SessionUpdateResponse = SessionUpdateResponses[keyof SessionUpdateResponses]

export type SessionChildrenData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/children"
}

export type SessionChildrenErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionChildrenError = SessionChildrenErrors[keyof SessionChildrenErrors]

export type SessionChildrenResponses = {
  /**
   * List of children
   */
  200: Array<Session>
}

export type SessionChildrenResponse = SessionChildrenResponses[keyof SessionChildrenResponses]

export type SessionTodoData = {
  body?: never
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/todo"
}

export type SessionTodoErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionTodoError = SessionTodoErrors[keyof SessionTodoErrors]

export type SessionTodoResponses = {
  /**
   * Todo list
   */
  200: Array<Todo>
}

export type SessionTodoResponse = SessionTodoResponses[keyof SessionTodoResponses]

export type SessionInitData = {
  body?: {
    modelID: string
    providerID: string
    messageID: string
  }
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/init"
}

export type SessionInitErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionInitError = SessionInitErrors[keyof SessionInitErrors]

export type SessionInitResponses = {
  /**
   * 200
   */
  200: boolean
}

export type SessionInitResponse = SessionInitResponses[keyof SessionInitResponses]

export type SessionForkData = {
  body?: {
    messageID?: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/fork"
}

export type SessionForkResponses = {
  /**
   * 200
   */
  200: Session
}

export type SessionForkResponse = SessionForkResponses[keyof SessionForkResponses]

export type SessionAbortData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/abort"
}

export type SessionAbortErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionAbortError = SessionAbortErrors[keyof SessionAbortErrors]

export type SessionAbortResponses = {
  /**
   * Aborted session
   */
  200: boolean
}

export type SessionAbortResponse = SessionAbortResponses[keyof SessionAbortResponses]

export type SessionUnshareData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/share"
}

export type SessionUnshareErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionUnshareError = SessionUnshareErrors[keyof SessionUnshareErrors]

export type SessionUnshareResponses = {
  /**
   * Successfully unshared session
   */
  200: Session
}

export type SessionUnshareResponse = SessionUnshareResponses[keyof SessionUnshareResponses]

export type SessionShareData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/share"
}

export type SessionShareErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionShareError = SessionShareErrors[keyof SessionShareErrors]

export type SessionShareResponses = {
  /**
   * Successfully shared session
   */
  200: Session
}

export type SessionShareResponse = SessionShareResponses[keyof SessionShareResponses]

export type SessionDiffData = {
  body?: never
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
    messageID?: string
  }
  url: "/session/{sessionID}/diff"
}

export type SessionDiffErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionDiffError = SessionDiffErrors[keyof SessionDiffErrors]

export type SessionDiffResponses = {
  /**
   * List of diffs
   */
  200: Array<FileDiff>
}

export type SessionDiffResponse = SessionDiffResponses[keyof SessionDiffResponses]

export type SessionSummarizeData = {
  body?: {
    providerID: string
    modelID: string
    auto?: boolean
  }
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/summarize"
}

export type SessionSummarizeErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionSummarizeError = SessionSummarizeErrors[keyof SessionSummarizeErrors]

export type SessionSummarizeResponses = {
  /**
   * Summarized session
   */
  200: boolean
}

export type SessionSummarizeResponse = SessionSummarizeResponses[keyof SessionSummarizeResponses]

export type SessionMessagesData = {
  body?: never
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
    limit?: number
  }
  url: "/session/{sessionID}/message"
}

export type SessionMessagesErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionMessagesError = SessionMessagesErrors[keyof SessionMessagesErrors]

export type SessionMessagesResponses = {
  /**
   * List of messages
   */
  200: Array<{
    info: Message
    parts: Array<Part>
  }>
}

export type SessionMessagesResponse = SessionMessagesResponses[keyof SessionMessagesResponses]

export type SessionPromptData = {
  body?: {
    messageID?: string
    model?: {
      providerID: string
      modelID: string
    }
    agent?: string
    noReply?: boolean
    /**
     * @deprecated tools and permissions have been merged, you can set permissions on the session itself now
     */
    tools?: {
      [key: string]: boolean
    }
    system?: string
    variant?: string
    parts: Array<TextPartInput | FilePartInput | AgentPartInput | SubtaskPartInput>
  }
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/message"
}

export type SessionPromptErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionPromptError = SessionPromptErrors[keyof SessionPromptErrors]

export type SessionPromptResponses = {
  /**
   * Created message
   */
  200: {
    info: AssistantMessage
    parts: Array<Part>
  }
}

export type SessionPromptResponse = SessionPromptResponses[keyof SessionPromptResponses]

export type SessionMessageData = {
  body?: never
  path: {
    /**
     * Session ID
     */
    sessionID: string
    /**
     * Message ID
     */
    messageID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/message/{messageID}"
}

export type SessionMessageErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionMessageError = SessionMessageErrors[keyof SessionMessageErrors]

export type SessionMessageResponses = {
  /**
   * Message
   */
  200: {
    info: Message
    parts: Array<Part>
  }
}

export type SessionMessageResponse = SessionMessageResponses[keyof SessionMessageResponses]

export type PartDeleteData = {
  body?: never
  path: {
    /**
     * Session ID
     */
    sessionID: string
    /**
     * Message ID
     */
    messageID: string
    /**
     * Part ID
     */
    partID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/message/{messageID}/part/{partID}"
}

export type PartDeleteErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PartDeleteError = PartDeleteErrors[keyof PartDeleteErrors]

export type PartDeleteResponses = {
  /**
   * Successfully deleted part
   */
  200: boolean
}

export type PartDeleteResponse = PartDeleteResponses[keyof PartDeleteResponses]

export type PartUpdateData = {
  body?: Part
  path: {
    /**
     * Session ID
     */
    sessionID: string
    /**
     * Message ID
     */
    messageID: string
    /**
     * Part ID
     */
    partID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/message/{messageID}/part/{partID}"
}

export type PartUpdateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PartUpdateError = PartUpdateErrors[keyof PartUpdateErrors]

export type PartUpdateResponses = {
  /**
   * Successfully updated part
   */
  200: Part
}

export type PartUpdateResponse = PartUpdateResponses[keyof PartUpdateResponses]

export type SessionPromptAsyncData = {
  body?: {
    messageID?: string
    model?: {
      providerID: string
      modelID: string
    }
    agent?: string
    noReply?: boolean
    /**
     * @deprecated tools and permissions have been merged, you can set permissions on the session itself now
     */
    tools?: {
      [key: string]: boolean
    }
    system?: string
    variant?: string
    parts: Array<TextPartInput | FilePartInput | AgentPartInput | SubtaskPartInput>
  }
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/prompt_async"
}

export type SessionPromptAsyncErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionPromptAsyncError = SessionPromptAsyncErrors[keyof SessionPromptAsyncErrors]

export type SessionPromptAsyncResponses = {
  /**
   * Prompt accepted
   */
  204: void
}

export type SessionPromptAsyncResponse = SessionPromptAsyncResponses[keyof SessionPromptAsyncResponses]

export type SessionCommandData = {
  body?: {
    messageID?: string
    agent?: string
    model?: string
    arguments: string
    command: string
    variant?: string
    parts?: Array<{
      id?: string
      type: "file"
      mime: string
      filename?: string
      url: string
      source?: FilePartSource
    }>
  }
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/command"
}

export type SessionCommandErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionCommandError = SessionCommandErrors[keyof SessionCommandErrors]

export type SessionCommandResponses = {
  /**
   * Created message
   */
  200: {
    info: AssistantMessage
    parts: Array<Part>
  }
}

export type SessionCommandResponse = SessionCommandResponses[keyof SessionCommandResponses]

export type SessionShellData = {
  body?: {
    agent: string
    model?: {
      providerID: string
      modelID: string
    }
    command: string
  }
  path: {
    /**
     * Session ID
     */
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/shell"
}

export type SessionShellErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionShellError = SessionShellErrors[keyof SessionShellErrors]

export type SessionShellResponses = {
  /**
   * Created message
   */
  200: AssistantMessage
}

export type SessionShellResponse = SessionShellResponses[keyof SessionShellResponses]

export type SessionRevertData = {
  body?: {
    messageID: string
    partID?: string
  }
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/revert"
}

export type SessionRevertErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionRevertError = SessionRevertErrors[keyof SessionRevertErrors]

export type SessionRevertResponses = {
  /**
   * Updated session
   */
  200: Session
}

export type SessionRevertResponse = SessionRevertResponses[keyof SessionRevertResponses]

export type SessionUnrevertData = {
  body?: never
  path: {
    sessionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/unrevert"
}

export type SessionUnrevertErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type SessionUnrevertError = SessionUnrevertErrors[keyof SessionUnrevertErrors]

export type SessionUnrevertResponses = {
  /**
   * Updated session
   */
  200: Session
}

export type SessionUnrevertResponse = SessionUnrevertResponses[keyof SessionUnrevertResponses]

export type PermissionRespondData = {
  body?: {
    response: "once" | "always" | "reject"
  }
  path: {
    sessionID: string
    permissionID: string
  }
  query?: {
    directory?: string
  }
  url: "/session/{sessionID}/permissions/{permissionID}"
}

export type PermissionRespondErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PermissionRespondError = PermissionRespondErrors[keyof PermissionRespondErrors]

export type PermissionRespondResponses = {
  /**
   * Permission processed successfully
   */
  200: boolean
}

export type PermissionRespondResponse = PermissionRespondResponses[keyof PermissionRespondResponses]

export type PermissionReplyData = {
  body?: {
    reply: "once" | "always" | "reject"
    message?: string
  }
  path: {
    requestID: string
  }
  query?: {
    directory?: string
  }
  url: "/permission/{requestID}/reply"
}

export type PermissionReplyErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type PermissionReplyError = PermissionReplyErrors[keyof PermissionReplyErrors]

export type PermissionReplyResponses = {
  /**
   * Permission processed successfully
   */
  200: boolean
}

export type PermissionReplyResponse = PermissionReplyResponses[keyof PermissionReplyResponses]

export type PermissionListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/permission"
}

export type PermissionListResponses = {
  /**
   * List of pending permissions
   */
  200: Array<PermissionRequest>
}

export type PermissionListResponse = PermissionListResponses[keyof PermissionListResponses]

export type QuestionListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/question"
}

export type QuestionListResponses = {
  /**
   * List of pending questions
   */
  200: Array<QuestionRequest>
}

export type QuestionListResponse = QuestionListResponses[keyof QuestionListResponses]

export type QuestionReplyData = {
  body?: {
    /**
     * User answers in order of questions (each answer is an array of selected labels)
     */
    answers: Array<QuestionAnswer>
  }
  path: {
    requestID: string
  }
  query?: {
    directory?: string
  }
  url: "/question/{requestID}/reply"
}

export type QuestionReplyErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type QuestionReplyError = QuestionReplyErrors[keyof QuestionReplyErrors]

export type QuestionReplyResponses = {
  /**
   * Question answered successfully
   */
  200: boolean
}

export type QuestionReplyResponse = QuestionReplyResponses[keyof QuestionReplyResponses]

export type QuestionRejectData = {
  body?: never
  path: {
    requestID: string
  }
  query?: {
    directory?: string
  }
  url: "/question/{requestID}/reject"
}

export type QuestionRejectErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type QuestionRejectError = QuestionRejectErrors[keyof QuestionRejectErrors]

export type QuestionRejectResponses = {
  /**
   * Question rejected successfully
   */
  200: boolean
}

export type QuestionRejectResponse = QuestionRejectResponses[keyof QuestionRejectResponses]

export type CommandListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/command"
}

export type CommandListResponses = {
  /**
   * List of commands
   */
  200: Array<Command>
}

export type CommandListResponse = CommandListResponses[keyof CommandListResponses]

export type ConfigProvidersData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/config/providers"
}

export type ConfigProvidersResponses = {
  /**
   * List of providers
   */
  200: {
    providers: Array<Provider>
    default: {
      [key: string]: string
    }
  }
}

export type ConfigProvidersResponse = ConfigProvidersResponses[keyof ConfigProvidersResponses]

export type ProviderListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/provider"
}

export type ProviderListResponses = {
  /**
   * List of providers
   */
  200: {
    all: Array<{
      api?: string
      name: string
      env: Array<string>
      id: string
      npm?: string
      models: {
        [key: string]: {
          id: string
          name: string
          family?: string
          release_date: string
          attachment: boolean
          reasoning: boolean
          temperature: boolean
          tool_call: boolean
          interleaved?:
            | true
            | {
                field: "reasoning_content" | "reasoning_details"
              }
          cost?: {
            input: number
            output: number
            cache_read?: number
            cache_write?: number
            context_over_200k?: {
              input: number
              output: number
              cache_read?: number
              cache_write?: number
            }
          }
          limit: {
            context: number
            output: number
          }
          modalities?: {
            input: Array<"text" | "audio" | "image" | "video" | "pdf">
            output: Array<"text" | "audio" | "image" | "video" | "pdf">
          }
          experimental?: boolean
          status?: "alpha" | "beta" | "deprecated"
          options: {
            [key: string]: unknown
          }
          headers?: {
            [key: string]: string
          }
          provider?: {
            npm: string
          }
          variants?: {
            [key: string]: {
              [key: string]: unknown
            }
          }
        }
      }
    }>
    default: {
      [key: string]: string
    }
    connected: Array<string>
  }
}

export type ProviderListResponse = ProviderListResponses[keyof ProviderListResponses]

export type ProviderAuthData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/provider/auth"
}

export type ProviderAuthResponses = {
  /**
   * Provider auth methods
   */
  200: {
    [key: string]: Array<ProviderAuthMethod>
  }
}

export type ProviderAuthResponse = ProviderAuthResponses[keyof ProviderAuthResponses]

export type ProviderOauthAuthorizeData = {
  body?: {
    /**
     * Auth method index
     */
    method: number
  }
  path: {
    /**
     * Provider ID
     */
    providerID: string
  }
  query?: {
    directory?: string
  }
  url: "/provider/{providerID}/oauth/authorize"
}

export type ProviderOauthAuthorizeErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type ProviderOauthAuthorizeError = ProviderOauthAuthorizeErrors[keyof ProviderOauthAuthorizeErrors]

export type ProviderOauthAuthorizeResponses = {
  /**
   * Authorization URL and method
   */
  200: ProviderAuthAuthorization
}

export type ProviderOauthAuthorizeResponse = ProviderOauthAuthorizeResponses[keyof ProviderOauthAuthorizeResponses]

export type ProviderOauthCallbackData = {
  body?: {
    /**
     * Auth method index
     */
    method: number
    /**
     * OAuth authorization code
     */
    code?: string
  }
  path: {
    /**
     * Provider ID
     */
    providerID: string
  }
  query?: {
    directory?: string
  }
  url: "/provider/{providerID}/oauth/callback"
}

export type ProviderOauthCallbackErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type ProviderOauthCallbackError = ProviderOauthCallbackErrors[keyof ProviderOauthCallbackErrors]

export type ProviderOauthCallbackResponses = {
  /**
   * OAuth callback processed successfully
   */
  200: boolean
}

export type ProviderOauthCallbackResponse = ProviderOauthCallbackResponses[keyof ProviderOauthCallbackResponses]

export type FindTextData = {
  body?: never
  path?: never
  query: {
    directory?: string
    pattern: string
  }
  url: "/find"
}

export type FindTextResponses = {
  /**
   * Matches
   */
  200: Array<{
    path: {
      text: string
    }
    lines: {
      text: string
    }
    line_number: number
    absolute_offset: number
    submatches: Array<{
      match: {
        text: string
      }
      start: number
      end: number
    }>
  }>
}

export type FindTextResponse = FindTextResponses[keyof FindTextResponses]

export type FindFilesData = {
  body?: never
  path?: never
  query: {
    directory?: string
    query: string
    dirs?: "true" | "false"
    type?: "file" | "directory"
    limit?: number
  }
  url: "/find/file"
}

export type FindFilesResponses = {
  /**
   * File paths
   */
  200: Array<string>
}

export type FindFilesResponse = FindFilesResponses[keyof FindFilesResponses]

export type FindSymbolsData = {
  body?: never
  path?: never
  query: {
    directory?: string
    query: string
  }
  url: "/find/symbol"
}

export type FindSymbolsResponses = {
  /**
   * Symbols
   */
  200: Array<Symbol>
}

export type FindSymbolsResponse = FindSymbolsResponses[keyof FindSymbolsResponses]

export type FileListData = {
  body?: never
  path?: never
  query: {
    directory?: string
    path: string
  }
  url: "/file"
}

export type FileListResponses = {
  /**
   * Files and directories
   */
  200: Array<FileNode>
}

export type FileListResponse = FileListResponses[keyof FileListResponses]

export type FileReadData = {
  body?: never
  path?: never
  query: {
    directory?: string
    path: string
  }
  url: "/file/content"
}

export type FileReadResponses = {
  /**
   * File content
   */
  200: FileContent
}

export type FileReadResponse = FileReadResponses[keyof FileReadResponses]

export type FileStatusData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/file/status"
}

export type FileStatusResponses = {
  /**
   * File status
   */
  200: Array<File>
}

export type FileStatusResponse = FileStatusResponses[keyof FileStatusResponses]

export type AppLogData = {
  body?: {
    /**
     * Service name for the log entry
     */
    service: string
    /**
     * Log level
     */
    level: "debug" | "info" | "error" | "warn"
    /**
     * Log message
     */
    message: string
    /**
     * Additional metadata for the log entry
     */
    extra?: {
      [key: string]: unknown
    }
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/log"
}

export type AppLogErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type AppLogError = AppLogErrors[keyof AppLogErrors]

export type AppLogResponses = {
  /**
   * Log entry written successfully
   */
  200: boolean
}

export type AppLogResponse = AppLogResponses[keyof AppLogResponses]

export type AppAgentsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/agent"
}

export type AppAgentsResponses = {
  /**
   * List of agents
   */
  200: Array<Agent>
}

export type AppAgentsResponse = AppAgentsResponses[keyof AppAgentsResponses]

export type McpStatusData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/mcp"
}

export type McpStatusResponses = {
  /**
   * MCP server status
   */
  200: {
    [key: string]: McpStatus
  }
}

export type McpStatusResponse = McpStatusResponses[keyof McpStatusResponses]

export type McpAddData = {
  body?: {
    name: string
    config: McpLocalConfig | McpRemoteConfig
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/mcp"
}

export type McpAddErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type McpAddError = McpAddErrors[keyof McpAddErrors]

export type McpAddResponses = {
  /**
   * MCP server added successfully
   */
  200: {
    [key: string]: McpStatus
  }
}

export type McpAddResponse = McpAddResponses[keyof McpAddResponses]

export type McpAuthRemoveData = {
  body?: never
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/mcp/{name}/auth"
}

export type McpAuthRemoveErrors = {
  /**
   * Not found
   */
  404: NotFoundError
}

export type McpAuthRemoveError = McpAuthRemoveErrors[keyof McpAuthRemoveErrors]

export type McpAuthRemoveResponses = {
  /**
   * OAuth credentials removed
   */
  200: {
    success: true
  }
}

export type McpAuthRemoveResponse = McpAuthRemoveResponses[keyof McpAuthRemoveResponses]

export type McpAuthStartData = {
  body?: never
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/mcp/{name}/auth"
}

export type McpAuthStartErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type McpAuthStartError = McpAuthStartErrors[keyof McpAuthStartErrors]

export type McpAuthStartResponses = {
  /**
   * OAuth flow started
   */
  200: {
    /**
     * URL to open in browser for authorization
     */
    authorizationUrl: string
  }
}

export type McpAuthStartResponse = McpAuthStartResponses[keyof McpAuthStartResponses]

export type McpAuthCallbackData = {
  body?: {
    /**
     * Authorization code from OAuth callback
     */
    code: string
  }
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/mcp/{name}/auth/callback"
}

export type McpAuthCallbackErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type McpAuthCallbackError = McpAuthCallbackErrors[keyof McpAuthCallbackErrors]

export type McpAuthCallbackResponses = {
  /**
   * OAuth authentication completed
   */
  200: McpStatus
}

export type McpAuthCallbackResponse = McpAuthCallbackResponses[keyof McpAuthCallbackResponses]

export type McpAuthAuthenticateData = {
  body?: never
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/mcp/{name}/auth/authenticate"
}

export type McpAuthAuthenticateErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type McpAuthAuthenticateError = McpAuthAuthenticateErrors[keyof McpAuthAuthenticateErrors]

export type McpAuthAuthenticateResponses = {
  /**
   * OAuth authentication completed
   */
  200: McpStatus
}

export type McpAuthAuthenticateResponse = McpAuthAuthenticateResponses[keyof McpAuthAuthenticateResponses]

export type McpConnectData = {
  body?: never
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/mcp/{name}/connect"
}

export type McpConnectResponses = {
  /**
   * MCP server connected successfully
   */
  200: boolean
}

export type McpConnectResponse = McpConnectResponses[keyof McpConnectResponses]

export type McpDisconnectData = {
  body?: never
  path: {
    name: string
  }
  query?: {
    directory?: string
  }
  url: "/mcp/{name}/disconnect"
}

export type McpDisconnectResponses = {
  /**
   * MCP server disconnected successfully
   */
  200: boolean
}

export type McpDisconnectResponse = McpDisconnectResponses[keyof McpDisconnectResponses]

export type ExperimentalResourceListData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/experimental/resource"
}

export type ExperimentalResourceListResponses = {
  /**
   * MCP resources
   */
  200: {
    [key: string]: McpResource
  }
}

export type ExperimentalResourceListResponse =
  ExperimentalResourceListResponses[keyof ExperimentalResourceListResponses]

export type LspStatusData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/lsp"
}

export type LspStatusResponses = {
  /**
   * LSP server status
   */
  200: Array<LspStatus>
}

export type LspStatusResponse = LspStatusResponses[keyof LspStatusResponses]

export type FormatterStatusData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/formatter"
}

export type FormatterStatusResponses = {
  /**
   * Formatter status
   */
  200: Array<FormatterStatus>
}

export type FormatterStatusResponse = FormatterStatusResponses[keyof FormatterStatusResponses]

export type TuiAppendPromptData = {
  body?: {
    text: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/append-prompt"
}

export type TuiAppendPromptErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type TuiAppendPromptError = TuiAppendPromptErrors[keyof TuiAppendPromptErrors]

export type TuiAppendPromptResponses = {
  /**
   * Prompt processed successfully
   */
  200: boolean
}

export type TuiAppendPromptResponse = TuiAppendPromptResponses[keyof TuiAppendPromptResponses]

export type TuiOpenHelpData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/open-help"
}

export type TuiOpenHelpResponses = {
  /**
   * Help dialog opened successfully
   */
  200: boolean
}

export type TuiOpenHelpResponse = TuiOpenHelpResponses[keyof TuiOpenHelpResponses]

export type TuiOpenSessionsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/open-sessions"
}

export type TuiOpenSessionsResponses = {
  /**
   * Session dialog opened successfully
   */
  200: boolean
}

export type TuiOpenSessionsResponse = TuiOpenSessionsResponses[keyof TuiOpenSessionsResponses]

export type TuiOpenThemesData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/open-themes"
}

export type TuiOpenThemesResponses = {
  /**
   * Theme dialog opened successfully
   */
  200: boolean
}

export type TuiOpenThemesResponse = TuiOpenThemesResponses[keyof TuiOpenThemesResponses]

export type TuiOpenModelsData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/open-models"
}

export type TuiOpenModelsResponses = {
  /**
   * Model dialog opened successfully
   */
  200: boolean
}

export type TuiOpenModelsResponse = TuiOpenModelsResponses[keyof TuiOpenModelsResponses]

export type TuiSubmitPromptData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/submit-prompt"
}

export type TuiSubmitPromptResponses = {
  /**
   * Prompt submitted successfully
   */
  200: boolean
}

export type TuiSubmitPromptResponse = TuiSubmitPromptResponses[keyof TuiSubmitPromptResponses]

export type TuiClearPromptData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/clear-prompt"
}

export type TuiClearPromptResponses = {
  /**
   * Prompt cleared successfully
   */
  200: boolean
}

export type TuiClearPromptResponse = TuiClearPromptResponses[keyof TuiClearPromptResponses]

export type TuiExecuteCommandData = {
  body?: {
    command: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/execute-command"
}

export type TuiExecuteCommandErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type TuiExecuteCommandError = TuiExecuteCommandErrors[keyof TuiExecuteCommandErrors]

export type TuiExecuteCommandResponses = {
  /**
   * Command executed successfully
   */
  200: boolean
}

export type TuiExecuteCommandResponse = TuiExecuteCommandResponses[keyof TuiExecuteCommandResponses]

export type TuiShowToastData = {
  body?: {
    title?: string
    message: string
    variant: "info" | "success" | "warning" | "error"
    /**
     * Duration in milliseconds
     */
    duration?: number
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/show-toast"
}

export type TuiShowToastResponses = {
  /**
   * Toast notification shown successfully
   */
  200: boolean
}

export type TuiShowToastResponse = TuiShowToastResponses[keyof TuiShowToastResponses]

export type TuiPublishData = {
  body?: EventTuiPromptAppend | EventTuiCommandExecute | EventTuiToastShow | EventTuiSessionSelect
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/publish"
}

export type TuiPublishErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type TuiPublishError = TuiPublishErrors[keyof TuiPublishErrors]

export type TuiPublishResponses = {
  /**
   * Event published successfully
   */
  200: boolean
}

export type TuiPublishResponse = TuiPublishResponses[keyof TuiPublishResponses]

export type TuiSelectSessionData = {
  body?: {
    /**
     * Session ID to navigate to
     */
    sessionID: string
  }
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/select-session"
}

export type TuiSelectSessionErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
  /**
   * Not found
   */
  404: NotFoundError
}

export type TuiSelectSessionError = TuiSelectSessionErrors[keyof TuiSelectSessionErrors]

export type TuiSelectSessionResponses = {
  /**
   * Session selected successfully
   */
  200: boolean
}

export type TuiSelectSessionResponse = TuiSelectSessionResponses[keyof TuiSelectSessionResponses]

export type TuiControlNextData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/control/next"
}

export type TuiControlNextResponses = {
  /**
   * Next TUI request
   */
  200: {
    path: string
    body: unknown
  }
}

export type TuiControlNextResponse = TuiControlNextResponses[keyof TuiControlNextResponses]

export type TuiControlResponseData = {
  body?: unknown
  path?: never
  query?: {
    directory?: string
  }
  url: "/tui/control/response"
}

export type TuiControlResponseResponses = {
  /**
   * Response submitted successfully
   */
  200: boolean
}

export type TuiControlResponseResponse = TuiControlResponseResponses[keyof TuiControlResponseResponses]

export type AuthSetData = {
  body?: Auth
  path: {
    providerID: string
  }
  query?: {
    directory?: string
  }
  url: "/auth/{providerID}"
}

export type AuthSetErrors = {
  /**
   * Bad request
   */
  400: BadRequestError
}

export type AuthSetError = AuthSetErrors[keyof AuthSetErrors]

export type AuthSetResponses = {
  /**
   * Successfully set authentication credentials
   */
  200: boolean
}

export type AuthSetResponse = AuthSetResponses[keyof AuthSetResponses]

export type EventSubscribeData = {
  body?: never
  path?: never
  query?: {
    directory?: string
  }
  url: "/event"
}

export type EventSubscribeResponses = {
  /**
   * Event stream
   */
  200: Event
}

export type EventSubscribeResponse = EventSubscribeResponses[keyof EventSubscribeResponses]
